{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","path":"js/jquery-3.4.1.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","path":"css/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/cupertino/source/css/code-highlighting.css","path":"css/code-highlighting.css","modified":0,"renderable":1},{"_id":"themes/cupertino/source/css/index.css","path":"css/index.css","modified":0,"renderable":1},{"_id":"themes/cupertino/source/css/components.css","path":"css/components.css","modified":0,"renderable":1},{"_id":"themes/cupertino/source/css/footer.css","path":"css/footer.css","modified":0,"renderable":1},{"_id":"themes/cupertino/source/css/nav.css","path":"css/nav.css","modified":1,"renderable":1},{"_id":"themes/cupertino/source/css/main.css","path":"css/main.css","modified":0,"renderable":1},{"_id":"themes/cupertino/source/css/paginator.css","path":"css/paginator.css","modified":0,"renderable":1},{"_id":"themes/cupertino/source/css/post-list.css","path":"css/post-list.css","modified":0,"renderable":1},{"_id":"themes/cupertino/source/css/post.css","path":"css/post.css","modified":0,"renderable":1},{"_id":"themes/cupertino/source/css/typography.css","path":"css/typography.css","modified":0,"renderable":1},{"_id":"themes/cupertino/source/css/var.css","path":"css/var.css","modified":0,"renderable":1},{"_id":"themes/cupertino/source/css/waline.css","path":"css/waline.css","modified":0,"renderable":1},{"_id":"themes/cupertino/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/cupertino/source/theme-img/github-mark-dark.png","path":"theme-img/github-mark-dark.png","modified":0,"renderable":1},{"_id":"themes/cupertino/source/theme-img/github-mark-light.png","path":"theme-img/github-mark-light.png","modified":0,"renderable":1},{"_id":"source/images/img1.png","path":"images/img1.png","modified":0,"renderable":0},{"_id":"themes/cupertino/source/theme-img/zhihu-mark-dark.png","path":"theme-img/zhihu-mark-dark.png","modified":1,"renderable":1},{"_id":"themes/cupertino/source/theme-img/zhihu-mark-light.png","path":"theme-img/zhihu-mark-light.png","modified":1,"renderable":1},{"_id":"themes/cupertino/source/theme-img/weibo-mark-dark.png","path":"theme-img/weibo-mark-dark.png","modified":1,"renderable":1},{"_id":"themes/cupertino/source/theme-img/weibo-mark-light.png","path":"theme-img/weibo-mark-light.png","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"bbe65ef1d2d2f299e041d89e09e7228402508ed2","modified":1614958725174},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"d2772ece6d4422ccdaa0359c3e07588834044052","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"b608c1f1322760dce9805285a602a95832730a2e","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"2712dda06c9d5ec719713aca788b6f0cfc54e473","modified":1614703355709},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"414914ebb159fac1922b056b905e570ac7521925","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"dfd555c00e85ffc4207c88968d12b219c1f086ec","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"f215d92a882247a7cc5ea80b241bedfcec0ea6ca","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"c1acd247e14588cdf101a69460cb8319c18cd078","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"581b0cbefdaa5f894922133989dd2d3bf71ded79","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"9c451e5efd72c5bb8b56e8c2b94be731e99db05b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"80759482d07063c091e940f964a1cf6693d3d406","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":499162500000},{"_id":"themes/cupertino/LICENSE","hash":"4272e3f540966f57f6ec6680111dd336139e1444","modified":1614703710632},{"_id":"themes/cupertino/README.md","hash":"0c091d87b3cc615e08e8d9ac9734e59365b0fda8","modified":1614703710632},{"_id":"themes/cupertino/_config.yml","hash":"4f5545ff96f046e62e75deb43ba88c56b8418e7c","modified":1614960018170},{"_id":"themes/cupertino/docs/configuration.md","hash":"c62d081b1dfeead0a5298ce51151e9fad67962e8","modified":1614703710632},{"_id":"themes/cupertino/languages/default.yml","hash":"1fc6be093e52626adf0c601f7a22e3a1fad101ec","modified":1614703710634},{"_id":"themes/cupertino/layout/index.ejs","hash":"96ce3c331a66cfec28b49b586142c145d959da6b","modified":1614703710634},{"_id":"themes/cupertino/layout/layout.ejs","hash":"165da551900ee44926d4d01647dd7e4ea8ea2379","modified":1614703710635},{"_id":"themes/cupertino/layout/post.ejs","hash":"de9b995d53581cd02913bd34a73409dbb41363b5","modified":1614703710635},{"_id":"themes/cupertino/docs/integrations/tidio.md","hash":"b49c1d2c88bc12ccff31e375c36a43746f306cf4","modified":1614703710633},{"_id":"themes/cupertino/docs/integrations/waline.md","hash":"beb0f600ea7099f33f61434a94ae81e095bba4ef","modified":1614703710633},{"_id":"themes/cupertino/layout/_partial/footer.ejs","hash":"5827dacbcad3c18a2c0ac818916ed83634af7c17","modified":1614703710634},{"_id":"themes/cupertino/layout/_partial/head.ejs","hash":"7a4fe0498ac9b9b1afa038c91d814f64582132b3","modified":1614703710634},{"_id":"themes/cupertino/layout/_partial/nav.ejs","hash":"650c743d2da2c27f219eec3ac4f2ed1dc842a015","modified":1614960014455},{"_id":"themes/cupertino/layout/_partial/paginator.ejs","hash":"c3adac66b9edc114e0287866da1117d92c614bb6","modified":1614703710634},{"_id":"themes/cupertino/source/css/code-highlighting.css","hash":"855d95a2b2f4781c15a0cfbab961c5b9a8b7df4f","modified":1614703710635},{"_id":"themes/cupertino/source/css/index.css","hash":"32abeed4f26ce851a5440fd3fcc8254465e18b1d","modified":1614703710636},{"_id":"themes/cupertino/source/css/components.css","hash":"74a02f47c56ebe8bd5c302186ff4d14e22cb56f2","modified":1614703710636},{"_id":"themes/cupertino/source/css/footer.css","hash":"89dc6696acde7e291a9b7519869c6d0582124f04","modified":1614703710636},{"_id":"themes/cupertino/source/css/nav.css","hash":"c0352e39fb1f67cef43c826d2fa5a12538f2d03f","modified":1614960005983},{"_id":"themes/cupertino/source/css/main.css","hash":"5d62fd4a79167f5262b2dce5ee8053cf3c0ed989","modified":1614703710636},{"_id":"themes/cupertino/source/css/paginator.css","hash":"d8b805b003e6358ec591f1d40a230611ac95ccb3","modified":1614703710636},{"_id":"themes/cupertino/source/css/post-list.css","hash":"b50e9691dc75d8d2fed235daed267ac394e98a23","modified":1614703710637},{"_id":"themes/cupertino/source/css/post.css","hash":"1bedf812f0af9d85e82265fd11b2f325845018ec","modified":1614957793681},{"_id":"themes/cupertino/source/css/typography.css","hash":"ac6003d9718e99fbfde4f599ca42bc057781c1e0","modified":1614703710637},{"_id":"themes/cupertino/source/css/var.css","hash":"32510c9db5f92c4c06e97b066c0720f1634c8101","modified":1614703710637},{"_id":"themes/cupertino/source/css/waline.css","hash":"31e17a913d79aa43ba6508433332160851be4743","modified":1614703710637},{"_id":"themes/cupertino/source/js/main.js","hash":"caa890d840c63afe570c371d7667d19a0ab584db","modified":1614703710637},{"_id":"themes/cupertino/source/theme-img/github-mark-dark.png","hash":"8e4af8e0da1da6fb685e86c19afb5322d559a8ca","modified":1614703710638},{"_id":"themes/cupertino/source/theme-img/github-mark-light.png","hash":"5740f0d2ea93806516b9c646e6e166aa5c0b44d9","modified":1614703710638},{"_id":"themes/cupertino/source/theme-img/patreon-logo-black.png","hash":"49ec544d938b13cc3ec519e157a40eaa432eee80","modified":1614703710638},{"_id":"themes/cupertino/source/theme-img/patreon-logo-white.png","hash":"a977d6017f976d18626c832bd2a91e9dbdc9c9a8","modified":1614703710639},{"_id":"themes/cupertino/docs/integrations/img/tidio-integration-url.png","hash":"73f1b81cc87b84df501bdb696789a32c93cc5a20","modified":1614703710633},{"_id":"source/_posts/img/img1.png","hash":"738421846aedc8b6d0b4cad43a3b8bb3fa5cd011","modified":1531214038000},{"_id":"source/_posts/NSURLSession基础.md","hash":"dea5b94f4b941af7e3ad59422f9be0ee6d9444b6","modified":1614950208505},{"_id":"source/.DS_Store","hash":"2bcfd21764b3a456e546852748a5ebd4932da3ec","modified":1614953910886},{"_id":"source/_posts/.DS_Store","hash":"c3747cdf2d53f23aeeeffc72914c7b77ce179f07","modified":1614950188714},{"_id":"source/images/img1.png","hash":"738421846aedc8b6d0b4cad43a3b8bb3fa5cd011","modified":1531214038000},{"_id":"source/_posts/iOS调试.md","hash":"f4831b76ed378464964a704d0021b82da093543a","modified":1614704530515},{"_id":"source/_posts/iOS并发编程之OperationQueues.md","hash":"1965409402241ad7fd449ae4fda92a575855b61c","modified":1614704511117},{"_id":"source/_posts/NSURLSession/images/img1.png","hash":"738421846aedc8b6d0b4cad43a3b8bb3fa5cd011","modified":1531214038000},{"_id":"source/_posts/NSURLSession.md","hash":"1608ff4843b1501b61f55a9fce290b65c624b662","modified":1614958843867},{"_id":"source/_posts/NSURLSession/.DS_Store","hash":"2bcfd21764b3a456e546852748a5ebd4932da3ec","modified":1614951553371},{"_id":"themes/cupertino/img/img1.png","hash":"738421846aedc8b6d0b4cad43a3b8bb3fa5cd011","modified":1531214038000},{"_id":"themes/cupertino/source/img/img1.png","hash":"738421846aedc8b6d0b4cad43a3b8bb3fa5cd011","modified":1531214038000},{"_id":"themes/cupertino/.DS_Store","hash":"e1f62f9502446091b848afebd81cf58b54e7277d","modified":1614953349582},{"_id":"themes/cupertino/source/.DS_Store","hash":"e1f62f9502446091b848afebd81cf58b54e7277d","modified":1614953349586},{"_id":"source/img/img1.png","hash":"738421846aedc8b6d0b4cad43a3b8bb3fa5cd011","modified":1531214038000},{"_id":"themes/cupertino/source/theme-img/zhihu-mark-light.png","hash":"cb883cb716990212d6b2857b9965c5d466a6a1d0","modified":1614959559411},{"_id":"themes/cupertino/source/theme-img/zhihu-mark-dark.png","hash":"5097e8e2d98902d8178916125c76f4418c256532","modified":1614959556251},{"_id":"themes/cupertino/source/theme-img/weibo-mark-dark.png","hash":"b469113c85c85c5f0618cfe1a86395f16df71651","modified":1614959880983},{"_id":"themes/cupertino/source/theme-img/weibo-mark-light.png","hash":"ea700d70df72dba749df50ea7c590874d41e2834","modified":1614959883107}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Hello World","cover_image":"https://t7.baidu.com/it/u=1788859373,3797492670&fm=193&f=GIF","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ncover_image: https://t7.baidu.com/it/u=1788859373,3797492670&fm=193&f=GIF\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2021-03-02T16:35:44.063Z","updated":"2021-03-05T15:38:45.174Z","_id":"ckls8p2950000u25w8yq435v6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"iOS并发编程之OperationQueues","_content":"### 1、Operation Queues简介\n\nOperation Queues是对GCD的封装，提供面向对象的API，实现多线程的解决方案。主要提供```NSOperation```(操作)和```NSOperationQueue```(操作队列)。\n\n1. **NSOperation**\n- 在线程中所要执行的代码段。\n- 操作队列所调度的任务。\n- 可以添加依赖关系和优先级。\n- 可以通过KVO观察执行状态。\n- 我们使用 **NSOperation** 子类 **NSInvocationOperation**、**NSBlockOperation**，或者**自定义**子类来封装操作。\n2. **NSOperationQueue**\n- 用来存放操作的队列。是由GCD提供的一个队列模型的Cocoa抽象。GCD提供了更加底层的控制，而操作队列则在GCD之上实现了一些方便的功能。\n- NSOperationQueue操作队列中的任务的执行顺序收到任务的isReady【就绪状态】状态和任务的队列优先级影响。这和GCD中的队列FIFO的执行顺序有很大区别。\n- 通过设置NSOperationQueue的最大并发操作数(maxConcurrentOperationCount)来控制任务执行是并发还是串行。\n- NSOperationQueue有两种不通类型的队列:主队列和自定义队列。主队列在主线程上运行，而自定义队列在后台执行。这两种队列中加入的任务都需要用NSOperation的子类来表示。\n\n### 3、NSOperationQueue\n- 主队列： 凡是添加到主队列中的操作，都会放到主线程中执行。串行执行。</br>\n```NSOperationQueue *queue = [NSOperationQueue mainQueue];```\n- 自定义队列：添加到这种队列中的操作，就会自动放到子线程中执行。具有串行和并发功能。</br>\n```NSOperationQueue *queue = [[NSOperationQueue alloc] init];```\n- 添加任务：创建任务后，添加到队列执行</br>\n```- (void)addOperation:(NSOperation *)op;```\n- 直接添加任务：直接通过block添加任务到队列</br>\n```- (void)addOperationWithBlock:(void (^)(void))block;```\n- 控制串行执行、并发执行: 使用```maxConcurrentOperationCount```控制串行和并发。</br>\n默认情况下为-1，表示不进行限制，可进行并发执行。</br>\n为1时，队列为串行队列。</br>\n只能串行执行。大于1时，队列为并发队列。\n\n```objc\n#pragma mark - NSOperationQueue\n- (void)operationQueueTest {\n    \n    NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n    queue.maxConcurrentOperationCount = 2;\n    \n    [queue addOperationWithBlock:^{\n        [self myTask1];\n    }];\n    \n    [queue addOperationWithBlock:^{\n        [self myTask2];\n    }];\n    \n    [queue addOperationWithBlock:^{\n        [self myTask3];\n    }];\n    \n}\n\n- (void)addToMainQueue {\n    \n    NSOperationQueue *mainQueue = [NSOperationQueue mainQueue];\n    \n    NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(myTask1) object:nil];\n    NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(myTask2) object:nil];\n    NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^{\n        [self myTask3];\n    }];\n    \n    \n    [mainQueue addOperation:op1];\n    [mainQueue addOperation:op2];\n    [mainQueue addOperation:op3];\n    \n}\n\n- (void)addToCustomQueue {\n    \n    NSOperationQueue *customQueue = [[NSOperationQueue alloc] init];\n//    customQueue.maxConcurrentOperationCount = 3;\n//    customQueue.maxConcurrentOperationCount = 2;\n    \n    NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(myTask1) object:nil];\n    NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(myTask2) object:nil];\n    NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^{\n        [self myTask3];\n    }];\n    \n    [op1 addDependency:op3];\n    [customQueue addOperation:op1];\n    [customQueue addOperation:op2];\n    [customQueue addOperation:op3];\n    \n}\n\n#pragma mark - tasks\n- (void)myTask1 {\n    NSLog(@\"执行Operation:%@\", [NSThread currentThread]);\n    for (NSInteger i = 0; i < 10; i++) {\n        NSLog(@\"task1---%ld---%@\", i, [NSThread currentThread]);\n    }\n}\n\n- (void)myTask2 {\n    NSLog(@\"执行Operation:%@\", [NSThread currentThread]);\n    for (NSInteger i = 0; i < 10; i++) {\n        NSLog(@\"task2---%ld---%@\", i, [NSThread currentThread]);\n    }\n}\n\n- (void)myTask3 {\n    NSLog(@\"执行Operation:%@\", [NSThread currentThread]);\n    for (NSInteger i = 0; i < 10; i++) {\n        NSLog(@\"task3---%ld---%@\", i, [NSThread currentThread]);\n    }\n}\n```\n\n### 4、NSOperation\n可以创建NSOperation子类后手动开启执行。也可以添加到队列中，让队列对任务进行管理。\n- 添加依赖：当依赖的任务执行完成后才会执行。</br>\n```- (void)addDependency:(NSOperation *)op;```\n- 移除依赖: 取消当前任务对 op 的依赖。</br>\n```- (void)removeDependency:(NSOperation *)op;```\n- 优先级: NSOperation 提供了```queuePriority```（优先级）属性。\n```objc\n// 优先级的取值\ntypedef NS_ENUM(NSInteger, NSOperationQueuePriority) {\n    NSOperationQueuePriorityVeryLow = -8L,\n    NSOperationQueuePriorityLow = -4L,\n    NSOperationQueuePriorityNormal = 0,\n    NSOperationQueuePriorityHigh = 4,\n    NSOperationQueuePriorityVeryHigh = 8\n};\n```\n> 对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。\n\n#### NSInvocationOperation\n```objc\n#pragma mark - NSInvocationOperation\n- (void)invocationOperationCreate {\n    \n    NSLog(@\"创建Operation:%@\", [NSThread currentThread]);\n    \n    NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(myTask1) object:nil];\n    \n    [op start];\n    \n}\n\n- (void)invocationOperationAtNewThread {\n    //在新线程中执行\n    [NSThread detachNewThreadSelector:@selector(invocationOperationCreate) toTarget:self withObject:nil];\n}\n```\n#### NSBlockOperation\n```objc\n#pragma mark - NSBlockOperation\n- (void)blockOperationCreate {\n    \n    NSLog(@\"创建Operation:%@\", [NSThread currentThread]);\n    \n    NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{\n        [self myTask1];\n    }];\n    \n    //新添加的任务，不在本线程执行，将开启新线程并发执行\n    [op addExecutionBlock:^{\n        [self myTask1];\n    }];\n    \n    [op addExecutionBlock:^{\n        [self myTask1];\n    }];\n    \n    [op start];\n}\n\n- (void)blockOperationAtNewThread {\n    [NSThread detachNewThreadSelector:@selector(blockOperationCreate) toTarget:self withObject:nil];\n}\n\n```\n#### 自定义NSOperation\n可以通过重写 main 或者 start 方法 来定义自己的 NSOperation 对象。重写main方法比较简单，我们不需要管理操作的状态属性  isExecuting 和 isFinished。当 main 执行完返回的时候，这个操作就结束了。如果重写start方法，需要自己管理状态，以便队列管理任务。\n```objc\n#import <Foundation/Foundation.h>\n\n@interface CustomOperation : NSOperation\n\n@end\n\n#import \"CustomOperation.h\"\n\n@implementation CustomOperation\n\n- (void)main {\n    NSLog(@\"执行Operation:%@\", [NSThread currentThread]);\n    for (NSInteger i = 0; i < 10; i++) {\n        NSLog(@\"---%ld---%@\", i, [NSThread currentThread]);\n    }\n}\n\n@end\n```\n```objc\n#pragma mark - CustomOperation\n- (void)customOperationCreate {\n    \n    CustomOperation *op = [[CustomOperation alloc] init];\n    \n    [op start];\n}\n\n- (void)customOperationAtNewThread {\n    [NSThread detachNewThreadSelector:@selector(customOperationCreate) toTarget:self withObject:nil];\n}\n```\n\n### 5、NSOperation、NSOperationQueue 线程间的通信\n一般在主线程里边进行 UI 刷新，耗时操作放在子线程。\n通过线程间的通信，先在其他线程中执行操作，等操作执行完了之后再回到主线程执行主线程的相应操作。\n```objc\n/**\n * 线程间通信\n */\n- (void)communication {\n\n    // 1.创建队列\n    NSOperationQueue *queue = [[NSOperationQueue alloc]init];\n\n    // 2.添加操作\n    [queue addOperationWithBlock:^{\n        // 异步进行耗时操作\n        for (int i = 0; i < 2; i++) {\n            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作\n            NSLog(@\"1---%@\", [NSThread currentThread]); // 打印当前线程\n        }\n\n        // 回到主线程\n        [[NSOperationQueue mainQueue] addOperationWithBlock:^{\n            // 进行一些 UI 刷新等操作\n            for (int i = 0; i < 2; i++) {\n                [NSThread sleepForTimeInterval:2]; // 模拟耗时操作\n                NSLog(@\"2---%@\", [NSThread currentThread]); // 打印当前线程\n            }\n        }];\n    }];\n}\n```\n### 6、NSOperation、NSOperationQueue 线程同步和线程安全\n通过线程加锁，实现线程的安全。如@synchronized、 NSLock、NSRecursiveLock、NSCondition、NSConditionLock、pthread_mutex、dispatch_semaphore、OSSpinLock、atomic(property) set/ge等等各种方式。\n\n> 参考\n>- [https://www.jianshu.com/p/4443d668e931](https://www.jianshu.com/p/4443d668e931)\n>- [https://www.jianshu.com/p/4b1d77054b35](https://www.jianshu.com/p/4b1d77054b35)\n>- [http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/](http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/)\n","source":"_posts/iOS并发编程之OperationQueues.md","raw":"---\ntitle: iOS并发编程之OperationQueues\n---\n### 1、Operation Queues简介\n\nOperation Queues是对GCD的封装，提供面向对象的API，实现多线程的解决方案。主要提供```NSOperation```(操作)和```NSOperationQueue```(操作队列)。\n\n1. **NSOperation**\n- 在线程中所要执行的代码段。\n- 操作队列所调度的任务。\n- 可以添加依赖关系和优先级。\n- 可以通过KVO观察执行状态。\n- 我们使用 **NSOperation** 子类 **NSInvocationOperation**、**NSBlockOperation**，或者**自定义**子类来封装操作。\n2. **NSOperationQueue**\n- 用来存放操作的队列。是由GCD提供的一个队列模型的Cocoa抽象。GCD提供了更加底层的控制，而操作队列则在GCD之上实现了一些方便的功能。\n- NSOperationQueue操作队列中的任务的执行顺序收到任务的isReady【就绪状态】状态和任务的队列优先级影响。这和GCD中的队列FIFO的执行顺序有很大区别。\n- 通过设置NSOperationQueue的最大并发操作数(maxConcurrentOperationCount)来控制任务执行是并发还是串行。\n- NSOperationQueue有两种不通类型的队列:主队列和自定义队列。主队列在主线程上运行，而自定义队列在后台执行。这两种队列中加入的任务都需要用NSOperation的子类来表示。\n\n### 3、NSOperationQueue\n- 主队列： 凡是添加到主队列中的操作，都会放到主线程中执行。串行执行。</br>\n```NSOperationQueue *queue = [NSOperationQueue mainQueue];```\n- 自定义队列：添加到这种队列中的操作，就会自动放到子线程中执行。具有串行和并发功能。</br>\n```NSOperationQueue *queue = [[NSOperationQueue alloc] init];```\n- 添加任务：创建任务后，添加到队列执行</br>\n```- (void)addOperation:(NSOperation *)op;```\n- 直接添加任务：直接通过block添加任务到队列</br>\n```- (void)addOperationWithBlock:(void (^)(void))block;```\n- 控制串行执行、并发执行: 使用```maxConcurrentOperationCount```控制串行和并发。</br>\n默认情况下为-1，表示不进行限制，可进行并发执行。</br>\n为1时，队列为串行队列。</br>\n只能串行执行。大于1时，队列为并发队列。\n\n```objc\n#pragma mark - NSOperationQueue\n- (void)operationQueueTest {\n    \n    NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n    queue.maxConcurrentOperationCount = 2;\n    \n    [queue addOperationWithBlock:^{\n        [self myTask1];\n    }];\n    \n    [queue addOperationWithBlock:^{\n        [self myTask2];\n    }];\n    \n    [queue addOperationWithBlock:^{\n        [self myTask3];\n    }];\n    \n}\n\n- (void)addToMainQueue {\n    \n    NSOperationQueue *mainQueue = [NSOperationQueue mainQueue];\n    \n    NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(myTask1) object:nil];\n    NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(myTask2) object:nil];\n    NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^{\n        [self myTask3];\n    }];\n    \n    \n    [mainQueue addOperation:op1];\n    [mainQueue addOperation:op2];\n    [mainQueue addOperation:op3];\n    \n}\n\n- (void)addToCustomQueue {\n    \n    NSOperationQueue *customQueue = [[NSOperationQueue alloc] init];\n//    customQueue.maxConcurrentOperationCount = 3;\n//    customQueue.maxConcurrentOperationCount = 2;\n    \n    NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(myTask1) object:nil];\n    NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(myTask2) object:nil];\n    NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^{\n        [self myTask3];\n    }];\n    \n    [op1 addDependency:op3];\n    [customQueue addOperation:op1];\n    [customQueue addOperation:op2];\n    [customQueue addOperation:op3];\n    \n}\n\n#pragma mark - tasks\n- (void)myTask1 {\n    NSLog(@\"执行Operation:%@\", [NSThread currentThread]);\n    for (NSInteger i = 0; i < 10; i++) {\n        NSLog(@\"task1---%ld---%@\", i, [NSThread currentThread]);\n    }\n}\n\n- (void)myTask2 {\n    NSLog(@\"执行Operation:%@\", [NSThread currentThread]);\n    for (NSInteger i = 0; i < 10; i++) {\n        NSLog(@\"task2---%ld---%@\", i, [NSThread currentThread]);\n    }\n}\n\n- (void)myTask3 {\n    NSLog(@\"执行Operation:%@\", [NSThread currentThread]);\n    for (NSInteger i = 0; i < 10; i++) {\n        NSLog(@\"task3---%ld---%@\", i, [NSThread currentThread]);\n    }\n}\n```\n\n### 4、NSOperation\n可以创建NSOperation子类后手动开启执行。也可以添加到队列中，让队列对任务进行管理。\n- 添加依赖：当依赖的任务执行完成后才会执行。</br>\n```- (void)addDependency:(NSOperation *)op;```\n- 移除依赖: 取消当前任务对 op 的依赖。</br>\n```- (void)removeDependency:(NSOperation *)op;```\n- 优先级: NSOperation 提供了```queuePriority```（优先级）属性。\n```objc\n// 优先级的取值\ntypedef NS_ENUM(NSInteger, NSOperationQueuePriority) {\n    NSOperationQueuePriorityVeryLow = -8L,\n    NSOperationQueuePriorityLow = -4L,\n    NSOperationQueuePriorityNormal = 0,\n    NSOperationQueuePriorityHigh = 4,\n    NSOperationQueuePriorityVeryHigh = 8\n};\n```\n> 对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。\n\n#### NSInvocationOperation\n```objc\n#pragma mark - NSInvocationOperation\n- (void)invocationOperationCreate {\n    \n    NSLog(@\"创建Operation:%@\", [NSThread currentThread]);\n    \n    NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(myTask1) object:nil];\n    \n    [op start];\n    \n}\n\n- (void)invocationOperationAtNewThread {\n    //在新线程中执行\n    [NSThread detachNewThreadSelector:@selector(invocationOperationCreate) toTarget:self withObject:nil];\n}\n```\n#### NSBlockOperation\n```objc\n#pragma mark - NSBlockOperation\n- (void)blockOperationCreate {\n    \n    NSLog(@\"创建Operation:%@\", [NSThread currentThread]);\n    \n    NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{\n        [self myTask1];\n    }];\n    \n    //新添加的任务，不在本线程执行，将开启新线程并发执行\n    [op addExecutionBlock:^{\n        [self myTask1];\n    }];\n    \n    [op addExecutionBlock:^{\n        [self myTask1];\n    }];\n    \n    [op start];\n}\n\n- (void)blockOperationAtNewThread {\n    [NSThread detachNewThreadSelector:@selector(blockOperationCreate) toTarget:self withObject:nil];\n}\n\n```\n#### 自定义NSOperation\n可以通过重写 main 或者 start 方法 来定义自己的 NSOperation 对象。重写main方法比较简单，我们不需要管理操作的状态属性  isExecuting 和 isFinished。当 main 执行完返回的时候，这个操作就结束了。如果重写start方法，需要自己管理状态，以便队列管理任务。\n```objc\n#import <Foundation/Foundation.h>\n\n@interface CustomOperation : NSOperation\n\n@end\n\n#import \"CustomOperation.h\"\n\n@implementation CustomOperation\n\n- (void)main {\n    NSLog(@\"执行Operation:%@\", [NSThread currentThread]);\n    for (NSInteger i = 0; i < 10; i++) {\n        NSLog(@\"---%ld---%@\", i, [NSThread currentThread]);\n    }\n}\n\n@end\n```\n```objc\n#pragma mark - CustomOperation\n- (void)customOperationCreate {\n    \n    CustomOperation *op = [[CustomOperation alloc] init];\n    \n    [op start];\n}\n\n- (void)customOperationAtNewThread {\n    [NSThread detachNewThreadSelector:@selector(customOperationCreate) toTarget:self withObject:nil];\n}\n```\n\n### 5、NSOperation、NSOperationQueue 线程间的通信\n一般在主线程里边进行 UI 刷新，耗时操作放在子线程。\n通过线程间的通信，先在其他线程中执行操作，等操作执行完了之后再回到主线程执行主线程的相应操作。\n```objc\n/**\n * 线程间通信\n */\n- (void)communication {\n\n    // 1.创建队列\n    NSOperationQueue *queue = [[NSOperationQueue alloc]init];\n\n    // 2.添加操作\n    [queue addOperationWithBlock:^{\n        // 异步进行耗时操作\n        for (int i = 0; i < 2; i++) {\n            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作\n            NSLog(@\"1---%@\", [NSThread currentThread]); // 打印当前线程\n        }\n\n        // 回到主线程\n        [[NSOperationQueue mainQueue] addOperationWithBlock:^{\n            // 进行一些 UI 刷新等操作\n            for (int i = 0; i < 2; i++) {\n                [NSThread sleepForTimeInterval:2]; // 模拟耗时操作\n                NSLog(@\"2---%@\", [NSThread currentThread]); // 打印当前线程\n            }\n        }];\n    }];\n}\n```\n### 6、NSOperation、NSOperationQueue 线程同步和线程安全\n通过线程加锁，实现线程的安全。如@synchronized、 NSLock、NSRecursiveLock、NSCondition、NSConditionLock、pthread_mutex、dispatch_semaphore、OSSpinLock、atomic(property) set/ge等等各种方式。\n\n> 参考\n>- [https://www.jianshu.com/p/4443d668e931](https://www.jianshu.com/p/4443d668e931)\n>- [https://www.jianshu.com/p/4b1d77054b35](https://www.jianshu.com/p/4b1d77054b35)\n>- [http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/](http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/)\n","slug":"iOS并发编程之OperationQueues","published":1,"date":"2019-01-26T09:06:46.000Z","updated":"2021-03-02T17:01:51.117Z","_id":"ckls9aiey00010y5wbihsdmef","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"1、Operation-Queues简介\"><a href=\"#1、Operation-Queues简介\" class=\"headerlink\" title=\"1、Operation Queues简介\"></a>1、Operation Queues简介</h3><p>Operation Queues是对GCD的封装，提供面向对象的API，实现多线程的解决方案。主要提供<code>NSOperation</code>(操作)和<code>NSOperationQueue</code>(操作队列)。</p>\n<ol>\n<li><strong>NSOperation</strong></li>\n</ol>\n<ul>\n<li>在线程中所要执行的代码段。</li>\n<li>操作队列所调度的任务。</li>\n<li>可以添加依赖关系和优先级。</li>\n<li>可以通过KVO观察执行状态。</li>\n<li>我们使用 <strong>NSOperation</strong> 子类 <strong>NSInvocationOperation</strong>、<strong>NSBlockOperation</strong>，或者<strong>自定义</strong>子类来封装操作。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>NSOperationQueue</strong></li>\n</ol>\n<ul>\n<li>用来存放操作的队列。是由GCD提供的一个队列模型的Cocoa抽象。GCD提供了更加底层的控制，而操作队列则在GCD之上实现了一些方便的功能。</li>\n<li>NSOperationQueue操作队列中的任务的执行顺序收到任务的isReady【就绪状态】状态和任务的队列优先级影响。这和GCD中的队列FIFO的执行顺序有很大区别。</li>\n<li>通过设置NSOperationQueue的最大并发操作数(maxConcurrentOperationCount)来控制任务执行是并发还是串行。</li>\n<li>NSOperationQueue有两种不通类型的队列:主队列和自定义队列。主队列在主线程上运行，而自定义队列在后台执行。这两种队列中加入的任务都需要用NSOperation的子类来表示。</li>\n</ul>\n<h3 id=\"3、NSOperationQueue\"><a href=\"#3、NSOperationQueue\" class=\"headerlink\" title=\"3、NSOperationQueue\"></a>3、NSOperationQueue</h3><ul>\n<li>主队列： 凡是添加到主队列中的操作，都会放到主线程中执行。串行执行。</br><br><code>NSOperationQueue *queue = [NSOperationQueue mainQueue];</code></li>\n<li>自定义队列：添加到这种队列中的操作，就会自动放到子线程中执行。具有串行和并发功能。</br><br><code>NSOperationQueue *queue = [[NSOperationQueue alloc] init];</code></li>\n<li>添加任务：创建任务后，添加到队列执行</br><br><code>- (void)addOperation:(NSOperation *)op;</code></li>\n<li>直接添加任务：直接通过block添加任务到队列</br><br><code>- (void)addOperationWithBlock:(void (^)(void))block;</code></li>\n<li>控制串行执行、并发执行: 使用<code>maxConcurrentOperationCount</code>控制串行和并发。</br><br>默认情况下为-1，表示不进行限制，可进行并发执行。</br><br>为1时，队列为串行队列。</br><br>只能串行执行。大于1时，队列为并发队列。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> mark - NSOperationQueue</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)operationQueueTest &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> *queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</span><br><span class=\"line\">    queue.maxConcurrentOperationCount = <span class=\"number\">2</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> myTask1];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> myTask2];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> myTask3];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)addToMainQueue &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> *mainQueue = [<span class=\"built_in\">NSOperationQueue</span> mainQueue];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSInvocationOperation</span> *op1 = [[<span class=\"built_in\">NSInvocationOperation</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(myTask1) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSInvocationOperation</span> *op2 = [[<span class=\"built_in\">NSInvocationOperation</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(myTask2) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> *op3 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> myTask3];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    [mainQueue addOperation:op1];</span><br><span class=\"line\">    [mainQueue addOperation:op2];</span><br><span class=\"line\">    [mainQueue addOperation:op3];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)addToCustomQueue &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> *customQueue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</span><br><span class=\"line\"><span class=\"comment\">//    customQueue.maxConcurrentOperationCount = 3;</span></span><br><span class=\"line\"><span class=\"comment\">//    customQueue.maxConcurrentOperationCount = 2;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSInvocationOperation</span> *op1 = [[<span class=\"built_in\">NSInvocationOperation</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(myTask1) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSInvocationOperation</span> *op2 = [[<span class=\"built_in\">NSInvocationOperation</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(myTask2) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> *op3 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> myTask3];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [op1 addDependency:op3];</span><br><span class=\"line\">    [customQueue addOperation:op1];</span><br><span class=\"line\">    [customQueue addOperation:op2];</span><br><span class=\"line\">    [customQueue addOperation:op3];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> mark - tasks</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)myTask1 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;执行Operation:%@&quot;</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;task1---%ld---%@&quot;</span>, i, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)myTask2 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;执行Operation:%@&quot;</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;task2---%ld---%@&quot;</span>, i, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)myTask3 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;执行Operation:%@&quot;</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;task3---%ld---%@&quot;</span>, i, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、NSOperation\"><a href=\"#4、NSOperation\" class=\"headerlink\" title=\"4、NSOperation\"></a>4、NSOperation</h3><p>可以创建NSOperation子类后手动开启执行。也可以添加到队列中，让队列对任务进行管理。</p>\n<ul>\n<li>添加依赖：当依赖的任务执行完成后才会执行。</br><br><code>- (void)addDependency:(NSOperation *)op;</code></li>\n<li>移除依赖: 取消当前任务对 op 的依赖。</br><br><code>- (void)removeDependency:(NSOperation *)op;</code></li>\n<li>优先级: NSOperation 提供了<code>queuePriority</code>（优先级）属性。<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 优先级的取值</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, <span class=\"built_in\">NSOperationQueuePriority</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueuePriorityVeryLow</span> = <span class=\"number\">-8</span>L,</span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueuePriorityLow</span> = <span class=\"number\">-4</span>L,</span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueuePriorityNormal</span> = <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueuePriorityHigh</span> = <span class=\"number\">4</span>,</span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueuePriorityVeryHigh</span> = <span class=\"number\">8</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"NSInvocationOperation\"><a href=\"#NSInvocationOperation\" class=\"headerlink\" title=\"NSInvocationOperation\"></a>NSInvocationOperation</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> mark - NSInvocationOperation</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)invocationOperationCreate &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;创建Operation:%@&quot;</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSInvocationOperation</span> *op = [[<span class=\"built_in\">NSInvocationOperation</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(myTask1) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [op start];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)invocationOperationAtNewThread &#123;</span><br><span class=\"line\">    <span class=\"comment\">//在新线程中执行</span></span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(invocationOperationCreate) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"NSBlockOperation\"><a href=\"#NSBlockOperation\" class=\"headerlink\" title=\"NSBlockOperation\"></a>NSBlockOperation</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> mark - NSBlockOperation</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)blockOperationCreate &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;创建Operation:%@&quot;</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> *op = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> myTask1];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//新添加的任务，不在本线程执行，将开启新线程并发执行</span></span><br><span class=\"line\">    [op addExecutionBlock:^&#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> myTask1];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [op addExecutionBlock:^&#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> myTask1];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [op start];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)blockOperationAtNewThread &#123;</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(blockOperationCreate) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"自定义NSOperation\"><a href=\"#自定义NSOperation\" class=\"headerlink\" title=\"自定义NSOperation\"></a>自定义NSOperation</h4><p>可以通过重写 main 或者 start 方法 来定义自己的 NSOperation 对象。重写main方法比较简单，我们不需要管理操作的状态属性  isExecuting 和 isFinished。当 main 执行完返回的时候，这个操作就结束了。如果重写start方法，需要自己管理状态，以便队列管理任务。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CustomOperation</span> : <span class=\"title\">NSOperation</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&quot;CustomOperation.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">CustomOperation</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)main &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;执行Operation:%@&quot;</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;---%ld---%@&quot;</span>, i, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> mark - CustomOperation</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)customOperationCreate &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    CustomOperation *op = [[CustomOperation alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [op start];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)customOperationAtNewThread &#123;</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(customOperationCreate) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5、NSOperation、NSOperationQueue-线程间的通信\"><a href=\"#5、NSOperation、NSOperationQueue-线程间的通信\" class=\"headerlink\" title=\"5、NSOperation、NSOperationQueue 线程间的通信\"></a>5、NSOperation、NSOperationQueue 线程间的通信</h3><p>一般在主线程里边进行 UI 刷新，耗时操作放在子线程。<br>通过线程间的通信，先在其他线程中执行操作，等操作执行完了之后再回到主线程执行主线程的相应操作。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 线程间通信</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)communication &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1.创建队列</span></span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> *queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc]init];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2.添加操作</span></span><br><span class=\"line\">    [queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 异步进行耗时操作</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">            [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">2</span>]; <span class=\"comment\">// 模拟耗时操作</span></span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;1---%@&quot;</span>, [<span class=\"built_in\">NSThread</span> currentThread]); <span class=\"comment\">// 打印当前线程</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 回到主线程</span></span><br><span class=\"line\">        [[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 进行一些 UI 刷新等操作</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">                [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">2</span>]; <span class=\"comment\">// 模拟耗时操作</span></span><br><span class=\"line\">                <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;2---%@&quot;</span>, [<span class=\"built_in\">NSThread</span> currentThread]); <span class=\"comment\">// 打印当前线程</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6、NSOperation、NSOperationQueue-线程同步和线程安全\"><a href=\"#6、NSOperation、NSOperationQueue-线程同步和线程安全\" class=\"headerlink\" title=\"6、NSOperation、NSOperationQueue 线程同步和线程安全\"></a>6、NSOperation、NSOperationQueue 线程同步和线程安全</h3><p>通过线程加锁，实现线程的安全。如@synchronized、 NSLock、NSRecursiveLock、NSCondition、NSConditionLock、pthread_mutex、dispatch_semaphore、OSSpinLock、atomic(property) set/ge等等各种方式。</p>\n<blockquote>\n<p>参考</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/4443d668e931\">https://www.jianshu.com/p/4443d668e931</a></li>\n<li><a href=\"https://www.jianshu.com/p/4b1d77054b35\">https://www.jianshu.com/p/4b1d77054b35</a></li>\n<li><a href=\"http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/\">http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/</a></li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1、Operation-Queues简介\"><a href=\"#1、Operation-Queues简介\" class=\"headerlink\" title=\"1、Operation Queues简介\"></a>1、Operation Queues简介</h3><p>Operation Queues是对GCD的封装，提供面向对象的API，实现多线程的解决方案。主要提供<code>NSOperation</code>(操作)和<code>NSOperationQueue</code>(操作队列)。</p>\n<ol>\n<li><strong>NSOperation</strong></li>\n</ol>\n<ul>\n<li>在线程中所要执行的代码段。</li>\n<li>操作队列所调度的任务。</li>\n<li>可以添加依赖关系和优先级。</li>\n<li>可以通过KVO观察执行状态。</li>\n<li>我们使用 <strong>NSOperation</strong> 子类 <strong>NSInvocationOperation</strong>、<strong>NSBlockOperation</strong>，或者<strong>自定义</strong>子类来封装操作。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>NSOperationQueue</strong></li>\n</ol>\n<ul>\n<li>用来存放操作的队列。是由GCD提供的一个队列模型的Cocoa抽象。GCD提供了更加底层的控制，而操作队列则在GCD之上实现了一些方便的功能。</li>\n<li>NSOperationQueue操作队列中的任务的执行顺序收到任务的isReady【就绪状态】状态和任务的队列优先级影响。这和GCD中的队列FIFO的执行顺序有很大区别。</li>\n<li>通过设置NSOperationQueue的最大并发操作数(maxConcurrentOperationCount)来控制任务执行是并发还是串行。</li>\n<li>NSOperationQueue有两种不通类型的队列:主队列和自定义队列。主队列在主线程上运行，而自定义队列在后台执行。这两种队列中加入的任务都需要用NSOperation的子类来表示。</li>\n</ul>\n<h3 id=\"3、NSOperationQueue\"><a href=\"#3、NSOperationQueue\" class=\"headerlink\" title=\"3、NSOperationQueue\"></a>3、NSOperationQueue</h3><ul>\n<li>主队列： 凡是添加到主队列中的操作，都会放到主线程中执行。串行执行。</br><br><code>NSOperationQueue *queue = [NSOperationQueue mainQueue];</code></li>\n<li>自定义队列：添加到这种队列中的操作，就会自动放到子线程中执行。具有串行和并发功能。</br><br><code>NSOperationQueue *queue = [[NSOperationQueue alloc] init];</code></li>\n<li>添加任务：创建任务后，添加到队列执行</br><br><code>- (void)addOperation:(NSOperation *)op;</code></li>\n<li>直接添加任务：直接通过block添加任务到队列</br><br><code>- (void)addOperationWithBlock:(void (^)(void))block;</code></li>\n<li>控制串行执行、并发执行: 使用<code>maxConcurrentOperationCount</code>控制串行和并发。</br><br>默认情况下为-1，表示不进行限制，可进行并发执行。</br><br>为1时，队列为串行队列。</br><br>只能串行执行。大于1时，队列为并发队列。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> mark - NSOperationQueue</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)operationQueueTest &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> *queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</span><br><span class=\"line\">    queue.maxConcurrentOperationCount = <span class=\"number\">2</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> myTask1];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> myTask2];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> myTask3];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)addToMainQueue &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> *mainQueue = [<span class=\"built_in\">NSOperationQueue</span> mainQueue];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSInvocationOperation</span> *op1 = [[<span class=\"built_in\">NSInvocationOperation</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(myTask1) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSInvocationOperation</span> *op2 = [[<span class=\"built_in\">NSInvocationOperation</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(myTask2) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> *op3 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> myTask3];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    [mainQueue addOperation:op1];</span><br><span class=\"line\">    [mainQueue addOperation:op2];</span><br><span class=\"line\">    [mainQueue addOperation:op3];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)addToCustomQueue &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> *customQueue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</span><br><span class=\"line\"><span class=\"comment\">//    customQueue.maxConcurrentOperationCount = 3;</span></span><br><span class=\"line\"><span class=\"comment\">//    customQueue.maxConcurrentOperationCount = 2;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSInvocationOperation</span> *op1 = [[<span class=\"built_in\">NSInvocationOperation</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(myTask1) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSInvocationOperation</span> *op2 = [[<span class=\"built_in\">NSInvocationOperation</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(myTask2) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> *op3 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> myTask3];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [op1 addDependency:op3];</span><br><span class=\"line\">    [customQueue addOperation:op1];</span><br><span class=\"line\">    [customQueue addOperation:op2];</span><br><span class=\"line\">    [customQueue addOperation:op3];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> mark - tasks</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)myTask1 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;执行Operation:%@&quot;</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;task1---%ld---%@&quot;</span>, i, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)myTask2 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;执行Operation:%@&quot;</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;task2---%ld---%@&quot;</span>, i, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)myTask3 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;执行Operation:%@&quot;</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;task3---%ld---%@&quot;</span>, i, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、NSOperation\"><a href=\"#4、NSOperation\" class=\"headerlink\" title=\"4、NSOperation\"></a>4、NSOperation</h3><p>可以创建NSOperation子类后手动开启执行。也可以添加到队列中，让队列对任务进行管理。</p>\n<ul>\n<li>添加依赖：当依赖的任务执行完成后才会执行。</br><br><code>- (void)addDependency:(NSOperation *)op;</code></li>\n<li>移除依赖: 取消当前任务对 op 的依赖。</br><br><code>- (void)removeDependency:(NSOperation *)op;</code></li>\n<li>优先级: NSOperation 提供了<code>queuePriority</code>（优先级）属性。<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 优先级的取值</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, <span class=\"built_in\">NSOperationQueuePriority</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueuePriorityVeryLow</span> = <span class=\"number\">-8</span>L,</span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueuePriorityLow</span> = <span class=\"number\">-4</span>L,</span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueuePriorityNormal</span> = <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueuePriorityHigh</span> = <span class=\"number\">4</span>,</span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueuePriorityVeryHigh</span> = <span class=\"number\">8</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"NSInvocationOperation\"><a href=\"#NSInvocationOperation\" class=\"headerlink\" title=\"NSInvocationOperation\"></a>NSInvocationOperation</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> mark - NSInvocationOperation</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)invocationOperationCreate &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;创建Operation:%@&quot;</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSInvocationOperation</span> *op = [[<span class=\"built_in\">NSInvocationOperation</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(myTask1) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [op start];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)invocationOperationAtNewThread &#123;</span><br><span class=\"line\">    <span class=\"comment\">//在新线程中执行</span></span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(invocationOperationCreate) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"NSBlockOperation\"><a href=\"#NSBlockOperation\" class=\"headerlink\" title=\"NSBlockOperation\"></a>NSBlockOperation</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> mark - NSBlockOperation</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)blockOperationCreate &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;创建Operation:%@&quot;</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> *op = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> myTask1];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//新添加的任务，不在本线程执行，将开启新线程并发执行</span></span><br><span class=\"line\">    [op addExecutionBlock:^&#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> myTask1];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [op addExecutionBlock:^&#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> myTask1];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [op start];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)blockOperationAtNewThread &#123;</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(blockOperationCreate) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"自定义NSOperation\"><a href=\"#自定义NSOperation\" class=\"headerlink\" title=\"自定义NSOperation\"></a>自定义NSOperation</h4><p>可以通过重写 main 或者 start 方法 来定义自己的 NSOperation 对象。重写main方法比较简单，我们不需要管理操作的状态属性  isExecuting 和 isFinished。当 main 执行完返回的时候，这个操作就结束了。如果重写start方法，需要自己管理状态，以便队列管理任务。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CustomOperation</span> : <span class=\"title\">NSOperation</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&quot;CustomOperation.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">CustomOperation</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)main &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;执行Operation:%@&quot;</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;---%ld---%@&quot;</span>, i, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> mark - CustomOperation</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)customOperationCreate &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    CustomOperation *op = [[CustomOperation alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [op start];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)customOperationAtNewThread &#123;</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(customOperationCreate) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5、NSOperation、NSOperationQueue-线程间的通信\"><a href=\"#5、NSOperation、NSOperationQueue-线程间的通信\" class=\"headerlink\" title=\"5、NSOperation、NSOperationQueue 线程间的通信\"></a>5、NSOperation、NSOperationQueue 线程间的通信</h3><p>一般在主线程里边进行 UI 刷新，耗时操作放在子线程。<br>通过线程间的通信，先在其他线程中执行操作，等操作执行完了之后再回到主线程执行主线程的相应操作。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 线程间通信</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)communication &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1.创建队列</span></span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> *queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc]init];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2.添加操作</span></span><br><span class=\"line\">    [queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 异步进行耗时操作</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">            [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">2</span>]; <span class=\"comment\">// 模拟耗时操作</span></span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;1---%@&quot;</span>, [<span class=\"built_in\">NSThread</span> currentThread]); <span class=\"comment\">// 打印当前线程</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 回到主线程</span></span><br><span class=\"line\">        [[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 进行一些 UI 刷新等操作</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">                [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">2</span>]; <span class=\"comment\">// 模拟耗时操作</span></span><br><span class=\"line\">                <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;2---%@&quot;</span>, [<span class=\"built_in\">NSThread</span> currentThread]); <span class=\"comment\">// 打印当前线程</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6、NSOperation、NSOperationQueue-线程同步和线程安全\"><a href=\"#6、NSOperation、NSOperationQueue-线程同步和线程安全\" class=\"headerlink\" title=\"6、NSOperation、NSOperationQueue 线程同步和线程安全\"></a>6、NSOperation、NSOperationQueue 线程同步和线程安全</h3><p>通过线程加锁，实现线程的安全。如@synchronized、 NSLock、NSRecursiveLock、NSCondition、NSConditionLock、pthread_mutex、dispatch_semaphore、OSSpinLock、atomic(property) set/ge等等各种方式。</p>\n<blockquote>\n<p>参考</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/4443d668e931\">https://www.jianshu.com/p/4443d668e931</a></li>\n<li><a href=\"https://www.jianshu.com/p/4b1d77054b35\">https://www.jianshu.com/p/4b1d77054b35</a></li>\n<li><a href=\"http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/\">http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/</a></li>\n</ul>\n</blockquote>\n"},{"title":"iOS调试","_content":"#### 断点\n>普通断点\n\n>全局断点\n\n>条件断点\n\n条件断点中的Add Symbolic BreakPoint为某一方法加断点，可以快速定位像unrecognized selector sent to instance 0xaxxxx 这种错误\n#### LLDB\n>lldb命令\n\nexpression命令\n```expression <cmd-options> -- <expr>```\n\n1.在代码运行过程中，可以通过执行某个表达式来动态改变程序运行的轨迹。\n如：\n\n```\n// 改变颜色\n(lldb) expression -- self.view.backgroundColor = [UIColor redColor]\n// 刷新界面\n(lldb) expression -- (void)[CATransaction flush]\n```\n\n2.打印\n\n```\n(lldb) expression -- self.view\n(UIView *) $1 = 0x00007fe322c18a10\n```\n\n>p & print & call命令\n\n一般情况下，我们直接用expression还是用得比较少的，更多时候我们用的是p、print、call。这三个命令其实都是expression --的别名\n\n>po命令\n\n打印对象\n\n>thread backtrace & bt命令\n\n线程堆栈信息\n\n>c & n & s & finish命令\n\nc/ continue/ thread continue: 这三个命令表示程序继续运行\nn/ next/ thread step-over: 这三个命令表示单步运行\ns/ step/ thread step-in: 这三个命令表示进入某个方法\nfinish/ step-out: 这两个命令表示直接走完当前方法，返回到上层frame\n\n>frame variable\n\n打印当前所有变量\n\nhttp://lldb.llvm.org/lldb-gdb.html\n#### 打印日志\n\n一般在代码中使用NSLog()方法在控制台输出信息。但是在真机上日志无法保存，所以需要将Log日志重定向输出到文件中保存。\n\n```objc\n//获取Document目录下的Log文件夹，若没有则新建\nNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\nNSString *logDirectory = [[paths objectAtIndex:0] stringByAppendingPathComponent:@\"Log\"];\nNSFileManager *fileManager = [NSFileManager defaultManager];\n\nBOOL fileExists = [fileManager fileExistsAtPath:logDirectory];\nif (!fileExists) {\n\t[fileManager createDirectoryAtPath:logDirectory  withIntermediateDirectories:YES attributes:nil error:nil];\n}\n\nNSDateFormatter *formatter = [[NSDateFormatter alloc] init];\n[formatter setLocale:[[NSLocale alloc] initWithLocaleIdentifier:@\"zh_CN\"]];\n[formatter setDateFormat:@\"yyyy-MM-dd HH:mm:ss\"];\n\n//每次启动后都保存一个新的日志文件中\nNSString *dateStr = [formatter stringFromDate:[NSDate date]];\nNSString *logFilePath = [logDirectory stringByAppendingFormat:@\"/%@.txt\",dateStr];\n\n// freopen 重定向输出输出流，将log输入到文件\nfreopen([logFilePath cStringUsingEncoding:NSASCIIStringEncoding], \"a+\", stdout);\nfreopen([logFilePath cStringUsingEncoding:NSASCIIStringEncoding], \"a+\", stderr);\n```\n在APP刚启动的方法中调用以上方法，并且在应用程序的Info.plist文件中添加UIFileSharingEnabled键，并将键值设置为YES。这样就可以通过iTune查看指定应用程序的共享文件夹，将文件拷贝到电脑上查看。\n\n```objc\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n```\n\n#### 内存分析和Instruments\nMRR模式(retain/release)\nARC模式下内存泄漏主要原因：循环引用、C语言API(如：core Foundation框架 Core Graphics框架)\n\n>1、静态内存分析（Analyze）\n\n不运行程序，直接对代码进行内存分析，查看代码是否有内存泄露或潜在的内存泄露\n优点：分析速度快，并且可以对所有的代码进行内存分析\n缺点：分析结果不一定准确（没有运行程序，根据代码的上下文语法结构）\n注意：如果有提示有内存泄露，一定结合代码查看代码是否有问题\n\n>2、动态内存分析(Profile => Instruments=>leaks)\n\n真正运行程序，对程序进行内存分析（查看内存分配情况、内存泄露）\n优点：分析非常准确，如果发现有提示内存泄露，基本可以断定代码问题\n缺点：分析效率低（真正运行了一段代码，才能对该代码进行内存分析）\n注意点：如果发现有内存泄露，基本需要修改代码（基本有内泄露）\n\n>Time Profiler\n\nCPU使用，运行时间\n\n#### 界面调试工具Reveal\n\n\n","source":"_posts/iOS调试.md","raw":"---\ntitle: iOS调试\n---\n#### 断点\n>普通断点\n\n>全局断点\n\n>条件断点\n\n条件断点中的Add Symbolic BreakPoint为某一方法加断点，可以快速定位像unrecognized selector sent to instance 0xaxxxx 这种错误\n#### LLDB\n>lldb命令\n\nexpression命令\n```expression <cmd-options> -- <expr>```\n\n1.在代码运行过程中，可以通过执行某个表达式来动态改变程序运行的轨迹。\n如：\n\n```\n// 改变颜色\n(lldb) expression -- self.view.backgroundColor = [UIColor redColor]\n// 刷新界面\n(lldb) expression -- (void)[CATransaction flush]\n```\n\n2.打印\n\n```\n(lldb) expression -- self.view\n(UIView *) $1 = 0x00007fe322c18a10\n```\n\n>p & print & call命令\n\n一般情况下，我们直接用expression还是用得比较少的，更多时候我们用的是p、print、call。这三个命令其实都是expression --的别名\n\n>po命令\n\n打印对象\n\n>thread backtrace & bt命令\n\n线程堆栈信息\n\n>c & n & s & finish命令\n\nc/ continue/ thread continue: 这三个命令表示程序继续运行\nn/ next/ thread step-over: 这三个命令表示单步运行\ns/ step/ thread step-in: 这三个命令表示进入某个方法\nfinish/ step-out: 这两个命令表示直接走完当前方法，返回到上层frame\n\n>frame variable\n\n打印当前所有变量\n\nhttp://lldb.llvm.org/lldb-gdb.html\n#### 打印日志\n\n一般在代码中使用NSLog()方法在控制台输出信息。但是在真机上日志无法保存，所以需要将Log日志重定向输出到文件中保存。\n\n```objc\n//获取Document目录下的Log文件夹，若没有则新建\nNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\nNSString *logDirectory = [[paths objectAtIndex:0] stringByAppendingPathComponent:@\"Log\"];\nNSFileManager *fileManager = [NSFileManager defaultManager];\n\nBOOL fileExists = [fileManager fileExistsAtPath:logDirectory];\nif (!fileExists) {\n\t[fileManager createDirectoryAtPath:logDirectory  withIntermediateDirectories:YES attributes:nil error:nil];\n}\n\nNSDateFormatter *formatter = [[NSDateFormatter alloc] init];\n[formatter setLocale:[[NSLocale alloc] initWithLocaleIdentifier:@\"zh_CN\"]];\n[formatter setDateFormat:@\"yyyy-MM-dd HH:mm:ss\"];\n\n//每次启动后都保存一个新的日志文件中\nNSString *dateStr = [formatter stringFromDate:[NSDate date]];\nNSString *logFilePath = [logDirectory stringByAppendingFormat:@\"/%@.txt\",dateStr];\n\n// freopen 重定向输出输出流，将log输入到文件\nfreopen([logFilePath cStringUsingEncoding:NSASCIIStringEncoding], \"a+\", stdout);\nfreopen([logFilePath cStringUsingEncoding:NSASCIIStringEncoding], \"a+\", stderr);\n```\n在APP刚启动的方法中调用以上方法，并且在应用程序的Info.plist文件中添加UIFileSharingEnabled键，并将键值设置为YES。这样就可以通过iTune查看指定应用程序的共享文件夹，将文件拷贝到电脑上查看。\n\n```objc\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n```\n\n#### 内存分析和Instruments\nMRR模式(retain/release)\nARC模式下内存泄漏主要原因：循环引用、C语言API(如：core Foundation框架 Core Graphics框架)\n\n>1、静态内存分析（Analyze）\n\n不运行程序，直接对代码进行内存分析，查看代码是否有内存泄露或潜在的内存泄露\n优点：分析速度快，并且可以对所有的代码进行内存分析\n缺点：分析结果不一定准确（没有运行程序，根据代码的上下文语法结构）\n注意：如果有提示有内存泄露，一定结合代码查看代码是否有问题\n\n>2、动态内存分析(Profile => Instruments=>leaks)\n\n真正运行程序，对程序进行内存分析（查看内存分配情况、内存泄露）\n优点：分析非常准确，如果发现有提示内存泄露，基本可以断定代码问题\n缺点：分析效率低（真正运行了一段代码，才能对该代码进行内存分析）\n注意点：如果发现有内存泄露，基本需要修改代码（基本有内泄露）\n\n>Time Profiler\n\nCPU使用，运行时间\n\n#### 界面调试工具Reveal\n\n\n","slug":"iOS调试","published":1,"date":"2018-07-11T03:24:42.000Z","updated":"2021-03-02T17:02:10.515Z","_id":"ckls9asa700030y5waayk95no","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"断点\"><a href=\"#断点\" class=\"headerlink\" title=\"断点\"></a>断点</h4><blockquote>\n<p>普通断点</p>\n</blockquote>\n<blockquote>\n<p>全局断点</p>\n</blockquote>\n<blockquote>\n<p>条件断点</p>\n</blockquote>\n<p>条件断点中的Add Symbolic BreakPoint为某一方法加断点，可以快速定位像unrecognized selector sent to instance 0xaxxxx 这种错误</p>\n<h4 id=\"LLDB\"><a href=\"#LLDB\" class=\"headerlink\" title=\"LLDB\"></a>LLDB</h4><blockquote>\n<p>lldb命令</p>\n</blockquote>\n<p>expression命令<br><code>expression &lt;cmd-options&gt; -- &lt;expr&gt;</code></p>\n<p>1.在代码运行过程中，可以通过执行某个表达式来动态改变程序运行的轨迹。<br>如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 改变颜色</span><br><span class=\"line\">(lldb) expression -- self.view.backgroundColor &#x3D; [UIColor redColor]</span><br><span class=\"line\">&#x2F;&#x2F; 刷新界面</span><br><span class=\"line\">(lldb) expression -- (void)[CATransaction flush]</span><br></pre></td></tr></table></figure>\n\n<p>2.打印</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) expression -- self.view</span><br><span class=\"line\">(UIView *) $1 &#x3D; 0x00007fe322c18a10</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>p &amp; print &amp; call命令</p>\n</blockquote>\n<p>一般情况下，我们直接用expression还是用得比较少的，更多时候我们用的是p、print、call。这三个命令其实都是expression –的别名</p>\n<blockquote>\n<p>po命令</p>\n</blockquote>\n<p>打印对象</p>\n<blockquote>\n<p>thread backtrace &amp; bt命令</p>\n</blockquote>\n<p>线程堆栈信息</p>\n<blockquote>\n<p>c &amp; n &amp; s &amp; finish命令</p>\n</blockquote>\n<p>c/ continue/ thread continue: 这三个命令表示程序继续运行<br>n/ next/ thread step-over: 这三个命令表示单步运行<br>s/ step/ thread step-in: 这三个命令表示进入某个方法<br>finish/ step-out: 这两个命令表示直接走完当前方法，返回到上层frame</p>\n<blockquote>\n<p>frame variable</p>\n</blockquote>\n<p>打印当前所有变量</p>\n<p><a href=\"http://lldb.llvm.org/lldb-gdb.html\">http://lldb.llvm.org/lldb-gdb.html</a></p>\n<h4 id=\"打印日志\"><a href=\"#打印日志\" class=\"headerlink\" title=\"打印日志\"></a>打印日志</h4><p>一般在代码中使用NSLog()方法在控制台输出信息。但是在真机上日志无法保存，所以需要将Log日志重定向输出到文件中保存。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取Document目录下的Log文件夹，若没有则新建</span></span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *paths = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>);</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *logDirectory = [[paths objectAtIndex:<span class=\"number\">0</span>] stringByAppendingPathComponent:<span class=\"string\">@&quot;Log&quot;</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSFileManager</span> *fileManager = [<span class=\"built_in\">NSFileManager</span> defaultManager];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> fileExists = [fileManager fileExistsAtPath:logDirectory];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!fileExists) &#123;</span><br><span class=\"line\">\t[fileManager createDirectoryAtPath:logDirectory  withIntermediateDirectories:<span class=\"literal\">YES</span> attributes:<span class=\"literal\">nil</span> error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSDateFormatter</span> *formatter = [[<span class=\"built_in\">NSDateFormatter</span> alloc] init];</span><br><span class=\"line\">[formatter setLocale:[[<span class=\"built_in\">NSLocale</span> alloc] initWithLocaleIdentifier:<span class=\"string\">@&quot;zh_CN&quot;</span>]];</span><br><span class=\"line\">[formatter setDateFormat:<span class=\"string\">@&quot;yyyy-MM-dd HH:mm:ss&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//每次启动后都保存一个新的日志文件中</span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *dateStr = [formatter stringFromDate:[<span class=\"built_in\">NSDate</span> date]];</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *logFilePath = [logDirectory stringByAppendingFormat:<span class=\"string\">@&quot;/%@.txt&quot;</span>,dateStr];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// freopen 重定向输出输出流，将log输入到文件</span></span><br><span class=\"line\">freopen([logFilePath cStringUsingEncoding:<span class=\"built_in\">NSASCIIStringEncoding</span>], <span class=\"string\">&quot;a+&quot;</span>, stdout);</span><br><span class=\"line\">freopen([logFilePath cStringUsingEncoding:<span class=\"built_in\">NSASCIIStringEncoding</span>], <span class=\"string\">&quot;a+&quot;</span>, stderr);</span><br></pre></td></tr></table></figure>\n<p>在APP刚启动的方法中调用以上方法，并且在应用程序的Info.plist文件中添加UIFileSharingEnabled键，并将键值设置为YES。这样就可以通过iTune查看指定应用程序的共享文件夹，将文件拷贝到电脑上查看。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"内存分析和Instruments\"><a href=\"#内存分析和Instruments\" class=\"headerlink\" title=\"内存分析和Instruments\"></a>内存分析和Instruments</h4><p>MRR模式(retain/release)<br>ARC模式下内存泄漏主要原因：循环引用、C语言API(如：core Foundation框架 Core Graphics框架)</p>\n<blockquote>\n<p>1、静态内存分析（Analyze）</p>\n</blockquote>\n<p>不运行程序，直接对代码进行内存分析，查看代码是否有内存泄露或潜在的内存泄露<br>优点：分析速度快，并且可以对所有的代码进行内存分析<br>缺点：分析结果不一定准确（没有运行程序，根据代码的上下文语法结构）<br>注意：如果有提示有内存泄露，一定结合代码查看代码是否有问题</p>\n<blockquote>\n<p>2、动态内存分析(Profile =&gt; Instruments=&gt;leaks)</p>\n</blockquote>\n<p>真正运行程序，对程序进行内存分析（查看内存分配情况、内存泄露）<br>优点：分析非常准确，如果发现有提示内存泄露，基本可以断定代码问题<br>缺点：分析效率低（真正运行了一段代码，才能对该代码进行内存分析）<br>注意点：如果发现有内存泄露，基本需要修改代码（基本有内泄露）</p>\n<blockquote>\n<p>Time Profiler</p>\n</blockquote>\n<p>CPU使用，运行时间</p>\n<h4 id=\"界面调试工具Reveal\"><a href=\"#界面调试工具Reveal\" class=\"headerlink\" title=\"界面调试工具Reveal\"></a>界面调试工具Reveal</h4>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"断点\"><a href=\"#断点\" class=\"headerlink\" title=\"断点\"></a>断点</h4><blockquote>\n<p>普通断点</p>\n</blockquote>\n<blockquote>\n<p>全局断点</p>\n</blockquote>\n<blockquote>\n<p>条件断点</p>\n</blockquote>\n<p>条件断点中的Add Symbolic BreakPoint为某一方法加断点，可以快速定位像unrecognized selector sent to instance 0xaxxxx 这种错误</p>\n<h4 id=\"LLDB\"><a href=\"#LLDB\" class=\"headerlink\" title=\"LLDB\"></a>LLDB</h4><blockquote>\n<p>lldb命令</p>\n</blockquote>\n<p>expression命令<br><code>expression &lt;cmd-options&gt; -- &lt;expr&gt;</code></p>\n<p>1.在代码运行过程中，可以通过执行某个表达式来动态改变程序运行的轨迹。<br>如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 改变颜色</span><br><span class=\"line\">(lldb) expression -- self.view.backgroundColor &#x3D; [UIColor redColor]</span><br><span class=\"line\">&#x2F;&#x2F; 刷新界面</span><br><span class=\"line\">(lldb) expression -- (void)[CATransaction flush]</span><br></pre></td></tr></table></figure>\n\n<p>2.打印</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) expression -- self.view</span><br><span class=\"line\">(UIView *) $1 &#x3D; 0x00007fe322c18a10</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>p &amp; print &amp; call命令</p>\n</blockquote>\n<p>一般情况下，我们直接用expression还是用得比较少的，更多时候我们用的是p、print、call。这三个命令其实都是expression –的别名</p>\n<blockquote>\n<p>po命令</p>\n</blockquote>\n<p>打印对象</p>\n<blockquote>\n<p>thread backtrace &amp; bt命令</p>\n</blockquote>\n<p>线程堆栈信息</p>\n<blockquote>\n<p>c &amp; n &amp; s &amp; finish命令</p>\n</blockquote>\n<p>c/ continue/ thread continue: 这三个命令表示程序继续运行<br>n/ next/ thread step-over: 这三个命令表示单步运行<br>s/ step/ thread step-in: 这三个命令表示进入某个方法<br>finish/ step-out: 这两个命令表示直接走完当前方法，返回到上层frame</p>\n<blockquote>\n<p>frame variable</p>\n</blockquote>\n<p>打印当前所有变量</p>\n<p><a href=\"http://lldb.llvm.org/lldb-gdb.html\">http://lldb.llvm.org/lldb-gdb.html</a></p>\n<h4 id=\"打印日志\"><a href=\"#打印日志\" class=\"headerlink\" title=\"打印日志\"></a>打印日志</h4><p>一般在代码中使用NSLog()方法在控制台输出信息。但是在真机上日志无法保存，所以需要将Log日志重定向输出到文件中保存。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取Document目录下的Log文件夹，若没有则新建</span></span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *paths = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>);</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *logDirectory = [[paths objectAtIndex:<span class=\"number\">0</span>] stringByAppendingPathComponent:<span class=\"string\">@&quot;Log&quot;</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSFileManager</span> *fileManager = [<span class=\"built_in\">NSFileManager</span> defaultManager];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> fileExists = [fileManager fileExistsAtPath:logDirectory];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!fileExists) &#123;</span><br><span class=\"line\">\t[fileManager createDirectoryAtPath:logDirectory  withIntermediateDirectories:<span class=\"literal\">YES</span> attributes:<span class=\"literal\">nil</span> error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSDateFormatter</span> *formatter = [[<span class=\"built_in\">NSDateFormatter</span> alloc] init];</span><br><span class=\"line\">[formatter setLocale:[[<span class=\"built_in\">NSLocale</span> alloc] initWithLocaleIdentifier:<span class=\"string\">@&quot;zh_CN&quot;</span>]];</span><br><span class=\"line\">[formatter setDateFormat:<span class=\"string\">@&quot;yyyy-MM-dd HH:mm:ss&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//每次启动后都保存一个新的日志文件中</span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *dateStr = [formatter stringFromDate:[<span class=\"built_in\">NSDate</span> date]];</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *logFilePath = [logDirectory stringByAppendingFormat:<span class=\"string\">@&quot;/%@.txt&quot;</span>,dateStr];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// freopen 重定向输出输出流，将log输入到文件</span></span><br><span class=\"line\">freopen([logFilePath cStringUsingEncoding:<span class=\"built_in\">NSASCIIStringEncoding</span>], <span class=\"string\">&quot;a+&quot;</span>, stdout);</span><br><span class=\"line\">freopen([logFilePath cStringUsingEncoding:<span class=\"built_in\">NSASCIIStringEncoding</span>], <span class=\"string\">&quot;a+&quot;</span>, stderr);</span><br></pre></td></tr></table></figure>\n<p>在APP刚启动的方法中调用以上方法，并且在应用程序的Info.plist文件中添加UIFileSharingEnabled键，并将键值设置为YES。这样就可以通过iTune查看指定应用程序的共享文件夹，将文件拷贝到电脑上查看。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"内存分析和Instruments\"><a href=\"#内存分析和Instruments\" class=\"headerlink\" title=\"内存分析和Instruments\"></a>内存分析和Instruments</h4><p>MRR模式(retain/release)<br>ARC模式下内存泄漏主要原因：循环引用、C语言API(如：core Foundation框架 Core Graphics框架)</p>\n<blockquote>\n<p>1、静态内存分析（Analyze）</p>\n</blockquote>\n<p>不运行程序，直接对代码进行内存分析，查看代码是否有内存泄露或潜在的内存泄露<br>优点：分析速度快，并且可以对所有的代码进行内存分析<br>缺点：分析结果不一定准确（没有运行程序，根据代码的上下文语法结构）<br>注意：如果有提示有内存泄露，一定结合代码查看代码是否有问题</p>\n<blockquote>\n<p>2、动态内存分析(Profile =&gt; Instruments=&gt;leaks)</p>\n</blockquote>\n<p>真正运行程序，对程序进行内存分析（查看内存分配情况、内存泄露）<br>优点：分析非常准确，如果发现有提示内存泄露，基本可以断定代码问题<br>缺点：分析效率低（真正运行了一段代码，才能对该代码进行内存分析）<br>注意点：如果发现有内存泄露，基本需要修改代码（基本有内泄露）</p>\n<blockquote>\n<p>Time Profiler</p>\n</blockquote>\n<p>CPU使用，运行时间</p>\n<h4 id=\"界面调试工具Reveal\"><a href=\"#界面调试工具Reveal\" class=\"headerlink\" title=\"界面调试工具Reveal\"></a>界面调试工具Reveal</h4>"},{"title":"NSURLSession","date":"2021-03-05T13:33:49.000Z","cover_image":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.songma.com%2Fwenzhang%2F20181224%2Fz0tgxdbl1ut88.png&refer=http%3A%2F%2Fimg.songma.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1617550831&t=8f6c592621827758620f34f1814d50f5","_content":"\n## 1.URL Session 类体系\n\n```\n1.NSURLSession ——会话类\n2.NSURLSessionConfiguration ——会话配置\n3.NSURLSessionTask——task抽象类\n        - NSURLSessionDataTask——普通task类\n            - NSRULSessionUploadTask——上传task类\n        - NSURLSessionDownloadTask——下载task类\n        - NSURLSessionStreamTask——流task类\n\n代理\nNSURLSessionDelegate\nNSURLSessionTaskDelegate\nNSURLSessionDataDelegate\nNSURLSessionDownloadDelegate\nNSURLSessionStreamDelegate\n\n其他\nNSURL\nNSURLRequest\nNSURLResponse\n    - NSHTTPURLResponse\nNSCachedURLResponse\n```\n\n## 2.NSURLSessionConfiguration\nNSURLSession可以通过sharedSession创建，也可以通过NSURLSessionConfiguration来创建。\n\n```objc\n//使用静态的sharedSession方法，该类使用共享的会话，该会话使用全局的Cache，Cookie和证书\n+ (NSURLSession *)sharedSession;  \n\n//通过sessionWithConfiguration:方法创建对象，也就是创建对应配置的会话，与NSURLSessionConfiguration合作使用\n+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration;  \n\n//通过设置配置、代理、队列来创建会话对象\n+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(id <NSURLSessionDelegate>)delegate delegateQueue:(NSOperationQueue *)queue;\n```\nNSURLSessionConfiguration其实是对NSURLSession的配置。\nNSURLSession有以下三种模式，分别对应NSURLSessionConfiguration的三种创建模式：\n\n```objc\n+ (NSURLSessionConfiguration *)defaultSessionConfiguration;  \n+ (NSURLSessionConfiguration *)ephemeralSessionConfiguration;  \n+ (NSURLSessionConfiguration *)backgroundSessionConfiguration:(NSString *)identifier;\n```\n\n* 默认会话模式（default）：工作模式类似于原来的NSURLConnection，使用的是基于磁盘缓存的持久化策略，使用用户keychain中保存的证书进行认证授权。\n* 瞬时会话模式（ephemeral）：该模式不使用磁盘保存任何数据。所有和会话相关的caches，证书，cookies等都被保存在RAM中，因此当程序使会话无效，这些缓存的数据就会被自动清空。（可以实现私密浏览）\n* 后台会话模式（background）：该模式在后台完成上传和下载（在系统的一个单独的进程中执行），在创建Configuration对象的时候需要提供一个NSString类型的ID用于标识完成工作的后台会话。\n\nNSURLSessionConfiguration各个属性的设置:\n\n```objc\n//如果在后台任务正在传输时程序退出，可以使用这个identifier在程序重新启动是创建一个新的configuration和session关联之前传输。\n@property(readonly, copy) NSString  *identifier;\n\n//默认为空，NSURLRequest附件的请求头。\n//这个属性会给所有使用该configuration的session生成的tasks中的NSURLRequest添加额外的请求头。\n//如果这里边添加的请求头跟NSURLRequest中重复了，侧优先使用NSURLRequest中的头\n@property(copy) NSDictionary  *HTTPAdditionalHeaders;\n\n//是否使用蜂窝网络，默认是yes.\n@property BOOL allowsCellularAccess;\n\n//给request指定每次接收数据超时间隔\n//如果下一次接受新数据用时超过该值，则发送一个请求超时给该request。默认为60s\n@property NSTimeInterval  timeoutIntervalForRequest;\n\n//给指定resource设定一个超时时间，resource需要在时间到达之前完成\n//默认是7天。 \n@property NSTimeInterval  timeoutIntervalForResource;\n\n//discretionary属性为YES时表示当程序在后台运作时由系统自己选择最佳的网络连接配置，该属性可以节省通过蜂窝连接的带宽。\n//在使用后台传输数据的时候，建议使用discretionary属性，而不是allowsCellularAccess属性，因为它会把WiFi和电源可用性考虑在内。\n@property (getter=isDiscretionary) BOOL discretionary;\n\n//表示当后台传输结束时，是否启动app.这个属性只对 生效，其他configuration类型会自动忽略该值。默认值是YES。\n@property BOOL sessionSendsLaunchEvents;\n\n//是否启动通道，可以用于加快网络请求，默认是NO\n@property BOOL HTTPShouldUsePipelining;\n\n/===========储存的相关属性=============/\n\n//存储cookie，清除存储，直接set为nil即可。\n//对于默认和后台的session，使用sharedHTTPCookieStorage。\n//对于短暂的session，cookie仅仅储存到内存，session失效时会自动清除。\n@property(retain) NSHTTPCookieStorage  *HTTPCookieStorage;\n\n//默认为yes,是否提供来自shareCookieStorge的cookie\n//如果想要自己提供cookie，可以使用HTTPAdditionalHeaders来提供。\n@property BOOL  HTTPShouldSetCookies;\n\n//证书存储，如果不使用，可set为nil.\n//默认和后台session，默认使用的sharedCredentialStorage.\n//短暂的session使用一个私有存储在内存中。session失效会自动清除。\n@property(retain) NSURLCredentialStorage *URLCredentialStorage;\n\n//缓存NSURLRequest的response。\n//默认的configuration，默认值的是sharedURLCache。\n//后台的configuration，默认值是nil\n//短暂的configuration，默认一个私有的cache于内存，session失效，cache自动清除。\n@property(retain) NSURLCache  *URLCache;\n\n//缓存策略，用于设置该会话中的Request的cachePolicy，如果Request有单独设置的话，以Request为准。\n//默认值是NSURLRequestUseProtocolCachePolicy\n@property NSURLRequestCachePolicy requestCachePolicy;\n```\n\n## 3.NSURLSessionTask\n根据NSURLSession来创建task进行网络请求\n* NSURLSessionDataTask,可以用来处理一般的网络请求，如 GET | POST 请求等。\n* NSURLSessionUploadTask，用于处理上传请求。\n* NSURLSessionDownloadTask，主要用于处理下载请求。\n\n可以直接用异步回调的形式，也可以用代理的方式进行网络请求\n#### 缓存:\n\n```objc\ntypedef NS_ENUM(NSUInteger, NSURLRequestCachePolicy)\n{\n    //对特定的 URL 请求使用网络协议中实现的缓存逻辑。这是默认的策略。\n    NSURLRequestUseProtocolCachePolicy = 0,\n\n    //数据需要从原始地址加载。不使用现有缓存。\n    NSURLRequestReloadIgnoringLocalCacheData = 1,\n\n    // 不仅忽略本地缓存，同时也忽略代理服务器或其他中间介质目前已有的、协议允许的缓存。\n    NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4, \n\n    NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData,\n\n    //无论缓存是否过期，先使用本地缓存数据。如果缓存中没有请求所对应的数据，那么从原始地址加载数据。\n    NSURLRequestReturnCacheDataElseLoad = 2,\n\n    //无论缓存是否过期，先使用本地缓存数据。如果缓存中没有请求所对应的数据，那么放弃从原始地址加载数据，请求视为失败（即：“离线”模式）。\n    NSURLRequestReturnCacheDataDontLoad = 3,\n\n    //从原始地址确认缓存数据的合法性后，缓存数据就可以使用，否则从原始地址加载。\n    NSURLRequestReloadRevalidatingCacheData = 5, \n};\n```\n\n#### NSURLSessionDataTask\n\n```objc\n//这两个方法需要设置代理来接收数据\n- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request;\n- (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url;\n\n//这两个方法在completionHandler来接收数据\n- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler;\n- (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler;\n```\n\n```objc\n#import \"ViewController.h\"\n\n@interface ViewController () <NSURLSessionDelegate,NSURLSessionTaskDelegate>\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    [self sendRequest];\n}\n- (void)sendRequest{\n    //创建请求\n    NSURL *url = [NSURL URLWithString:@\"http://httpbin.org/get\"];\n    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];\n    //设置request的缓存策略（决定该request是否要从缓存中获取）\n    request.cachePolicy = NSURLRequestReturnCacheDataElseLoad;\n    \n    //创建配置（决定要不要将数据和响应缓存在磁盘）\n    NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];\n    //configuration.requestCachePolicy = NSURLRequestReturnCacheDataElseLoad;\n    \n    //创建会话\n    NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:nil];\n    //生成任务\n    NSURLSessionDataTask *task = [session dataTaskWithRequest:request];\n    //创建的task是停止状态，需要我们去启动\n    [task resume];\n}\n//1.接收到服务器响应的时候调用\n- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask\ndidReceiveResponse:(NSURLResponse *)response\n completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler{\n    NSLog(@\"接收响应\");\n    //必须告诉系统是否接收服务器返回的数据\n    //默认是completionHandler(NSURLSessionResponseAllow)\n    //可以再这边通过响应的statusCode来判断否接收服务器返回的数据\n    completionHandler(NSURLSessionResponseAllow);\n}\n//2.接受到服务器返回数据的时候调用,可能被调用多次\n- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data{\n    NSLog(@\"接收到数据\");\n    //一般在这边进行数据的拼接，在方法3才将完整数据回调\n//    NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil];\n}\n//3.请求完成或者是失败的时候调用\n- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task\ndidCompleteWithError:(nullable NSError *)error{\n    NSLog(@\"请求完成或者是失败\");\n    //在这边进行完整数据的解析，回调\n}\n//4.将要缓存响应的时候调用（必须是默认会话模式，GET请求才可以）\n- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask\n willCacheResponse:(NSCachedURLResponse *)proposedResponse\n completionHandler:(void (^)(NSCachedURLResponse * _Nullable cachedResponse))completionHandler{\n    //可以在这边更改是否缓存，默认的话是completionHandler(proposedResponse)\n    //不想缓存的话可以设置completionHandler(nil)\n    completionHandler(proposedResponse);\n}\n@end\n```\n\n```objc\nNSURL *url = [NSURL URLWithString:@\"http://www.connect.com/login\"];\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];\nrequest.HTTPMethod = @\"POST\";\nrequest.HTTPBody = [@\"username=Tom&pwd=123\" dataUsingEncoding:NSUTF8StringEncoding];\n\n//使用全局的会话\nNSURLSession *session = [NSURLSession sharedSession];\n// 通过request初始化task\nNSURLSessionTask *task = [session dataTaskWithRequest:request\n                                   completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) { \n    NSLog(@\"%@\", [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]);\n }];\n//创建的task是停止状态，需要我们去启动\n[task resume];\n```\n\n#### NSURLSessionUploadTask\n\n```objc\n/=========代理方式===========/\n//通过文件url来上传\n- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL;  \n//通过文件data来上传\n- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData;  \n//通过文件流来上传\n- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request;\n\n/=========Block方式===========/\n- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;  \n- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;\n```\n\n这三种上传方式分别针对什么应用场景呢？\n* NSData：如果对象已经在内存里\n* File：如果对象在磁盘上，这样做有助于降低内存使用\n* Stream：通过流对象，你可以不用一次性将所有的流数据加载到内存中\n不过使用Stream一定要实现URLSession:task:needNewBodyStream:，因为Session没办法在重新尝试发送Stream的时候找到数据源。\n\n```objc\n//上传图片\n- (void)uploadRequest{\n    //创建请求\n    NSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://www.freeimagehosting.net/upload.php\"]];\n    //如果是上传文字就是@\"application/json\"\n    [request addValue:@\"image/jpeg\" forHTTPHeaderField:@\"Content-Type\"];\n    [request addValue:@\"text/html\" forHTTPHeaderField:@\"Accept\"];\n    [request setHTTPMethod:@\"POST\"];\n    [request setCachePolicy:NSURLRequestReloadIgnoringCacheData];\n    [request setTimeoutInterval:20];\n    NSData * imagedata = UIImageJPEGRepresentation([UIImage imageNamed:@\"person\"],1.0);\n    \n    //创建配置（决定要不要将数据和响应缓存在磁盘）\n    NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];\n    //创建会话\n    NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:nil];\n    \n    NSURLSessionUploadTask * uploadtask = [session uploadTaskWithRequest:request fromData:imagedata completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n        //发送完成的回调\n        \n    }];\n    [uploadtask resume];\n}\n//发送数据过程中会执行(执行多次)\n-(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend{\n    NSLog(@\"发送数据中\");\n    //在这边监听发送的进度\n    //progress = totalBytesSent/(float)totalBytesExpectedToSend\n}\n```\n\n#### NSURLSessionDownloadTask\n\n* 下载文件可以实现断点下载\n* 内部已经完成了边接收数据边写入沙盒的操作（直接下载到磁盘）\n* 支持BackgroundSession（后台下载）\n\n使用NSURLSessionDownloadTask 下载文件的过程与前面差不多，需要注意的是文件下载文件之后会自动保存到一个临时目录(temp)，需要开发人员自己将此文件重新放到其他指定的目录中。 或者直接在内存里面显示, 默认异步的.NSURLSession 自动不会出现内存暴涨情况\n\n```objc\n/=========代理方式===========/\n- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request;  \n- (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url;  \n//通过之前已经下载的数据来创建下载任务\n- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData;  \n\n/=========Block方式===========/\n- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;  \n- (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;  \n- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;\n```\n\n```objc\n- (void)downloadRequest{\n    //创建请求\n    NSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://httpbin.org/image/jpeg\"]];\n    \n    //创建配置（决定要不要将数据和响应缓存在磁盘）\n    NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];\n    //创建会话\n    NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:nil];\n    \n    NSURLSessionDownloadTask * downloadtask = [session downloadTaskWithRequest:request];\n    [downloadtask resume];\n}\n\n//1. downloadTask下载过程中会执行\n- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite{\n    NSLog(@\"下载中...\");\n    NSLog(@\"写入数据大小%lld，总写入数据大小%lld，总期望数据大小%lld\",bytesWritten,totalBytesWritten,totalBytesExpectedToWrite);\n    //监听下载的进度\n}\n//2.downloadTask下载完成的时候会执行\n- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location{\n    NSLog(@\"下载完成\");\n       //该方法内部已经完成了边接收数据边写沙盒的操作，解决了内存飙升的问题\n    //对数据进行使用，或者保存（默认存储到临时文件夹 tmp 中，需要剪切文件到 cache）\n    \n    //保存\n    NSString *filePath = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:downloadTask.response.suggestedFilename];\n    [[NSFileManager defaultManager] moveItemAtURL:location toURL:[NSURL fileURLWithPath:filePath] error:nil];\n\n    //使用\n    NSData * data = [NSData dataWithContentsOfURL:location.filePathURL];\n    UIImage * image = [UIImage imageWithData:data];\n    UIImageWriteToSavedPhotosAlbum(image, nil,nil,nil);\n}\n//3.请求完成或者是失败的时候调用(Session层次的Task完成的事件)\n- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task\ndidCompleteWithError:(nullable NSError *)error{\n    NSLog(@\"请求完成或者是失败\");\n}\n```\n\n断点续传:\n\n```objc\n// 使用这种方式取消下载可以得到将来用来恢复的数据,保存起来\n[self.task cancelByProducingResumeData:^(NSData *resumeData) {\n    self.resumeData = resumeData;\n}];\n\n// 由于下载失败导致的下载中断会进入此协议方法,也可以得到用来恢复的数据\n- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error\n{\n    // 保存恢复数据\n    self.resumeData = error.userInfo[NSURLSessionDownloadTaskResumeData];\n}\n\n// 恢复下载时接过保存的恢复数据\nself.task = [self.session downloadTaskWithResumeData:self.resumeData];\n// 启动任务\n[self.task resume];\n```\n\n后台下载\n\n使用后台会话进行下程序退出到后台也能正常下载完成,但是程序在后台UI无法更新,不能获取进度;这时,我们需要通过应用程序代理进行UI更新,原理如图:\n\n![](/images/img1.png)\n\n当NSURLSession在后台开启几个任务之后,如果其中有任务完成,系统就会会调用此APP的代理方法:```- (void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifiercompletionHandler:(void (^)(void))completionHandler```里进行完成的操作. 通常我们会保持此对象,直到最后一个任务完成; \n此时会重新通过会话标识(config中设置的)找到对应会话并调用NSURLSession的```-(void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession * )session```代理方法例进行UI的更新.并调用completionHandler通知系统已经完成所有操作。具体如下:\n\n```objc\n-(void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler{\n\n    //backgroundSessionCompletionHandler是自定义的一个属性\n    self.backgroundSessionCompletionHandler=completionHandler;   \n}\n\n-(void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session{\n    AppDelegate *appDelegate = (AppDelegate *)[[UIApplication sharedApplication] delegate];\n\n    //Other Operation....\n\n    if (appDelegate.backgroundSessionCompletionHandler) {\n\n        void (^completionHandler)() = appDelegate.backgroundSessionCompletionHandler;     \n        appDelegate.backgroundSessionCompletionHandler = nil;        \n        completionHandler();\n    }\n}\n```\n\n使用GCD进行一次发起多个请求，全部完成后进行统一处理\n\n```objc\nlet group : dispatch_group_t = dispatch_group_create()\nlet queue : dispatch_queue_t = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)\n        \ndispatch_group_async(group, queue) { \n  dispatch_group_enter(group)\n  //发起第一个请求\n}\n\ndispatch_group_async(group, queue) {\n  dispatch_group_enter(group)\n  //发起第二个请求\n}\n\ndispatch_group_notify(group, queue) {\n  //全部完成后，进行统一处理\n}\n\n//每个请求完成时，调用dispatch_group_leave(group)\n```\n\n参考:</br>\nhttps://www.jianshu.com/p/a8fc22afb739\nhttp://blog.csdn.net/csdnhaoren13/article/details/50809506\n","source":"_posts/NSURLSession.md","raw":"---\ntitle: NSURLSession\ndate: 2021-03-05 21:33:49\ncover_image: https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.songma.com%2Fwenzhang%2F20181224%2Fz0tgxdbl1ut88.png&refer=http%3A%2F%2Fimg.songma.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1617550831&t=8f6c592621827758620f34f1814d50f5\ntags:\n---\n\n## 1.URL Session 类体系\n\n```\n1.NSURLSession ——会话类\n2.NSURLSessionConfiguration ——会话配置\n3.NSURLSessionTask——task抽象类\n        - NSURLSessionDataTask——普通task类\n            - NSRULSessionUploadTask——上传task类\n        - NSURLSessionDownloadTask——下载task类\n        - NSURLSessionStreamTask——流task类\n\n代理\nNSURLSessionDelegate\nNSURLSessionTaskDelegate\nNSURLSessionDataDelegate\nNSURLSessionDownloadDelegate\nNSURLSessionStreamDelegate\n\n其他\nNSURL\nNSURLRequest\nNSURLResponse\n    - NSHTTPURLResponse\nNSCachedURLResponse\n```\n\n## 2.NSURLSessionConfiguration\nNSURLSession可以通过sharedSession创建，也可以通过NSURLSessionConfiguration来创建。\n\n```objc\n//使用静态的sharedSession方法，该类使用共享的会话，该会话使用全局的Cache，Cookie和证书\n+ (NSURLSession *)sharedSession;  \n\n//通过sessionWithConfiguration:方法创建对象，也就是创建对应配置的会话，与NSURLSessionConfiguration合作使用\n+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration;  \n\n//通过设置配置、代理、队列来创建会话对象\n+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(id <NSURLSessionDelegate>)delegate delegateQueue:(NSOperationQueue *)queue;\n```\nNSURLSessionConfiguration其实是对NSURLSession的配置。\nNSURLSession有以下三种模式，分别对应NSURLSessionConfiguration的三种创建模式：\n\n```objc\n+ (NSURLSessionConfiguration *)defaultSessionConfiguration;  \n+ (NSURLSessionConfiguration *)ephemeralSessionConfiguration;  \n+ (NSURLSessionConfiguration *)backgroundSessionConfiguration:(NSString *)identifier;\n```\n\n* 默认会话模式（default）：工作模式类似于原来的NSURLConnection，使用的是基于磁盘缓存的持久化策略，使用用户keychain中保存的证书进行认证授权。\n* 瞬时会话模式（ephemeral）：该模式不使用磁盘保存任何数据。所有和会话相关的caches，证书，cookies等都被保存在RAM中，因此当程序使会话无效，这些缓存的数据就会被自动清空。（可以实现私密浏览）\n* 后台会话模式（background）：该模式在后台完成上传和下载（在系统的一个单独的进程中执行），在创建Configuration对象的时候需要提供一个NSString类型的ID用于标识完成工作的后台会话。\n\nNSURLSessionConfiguration各个属性的设置:\n\n```objc\n//如果在后台任务正在传输时程序退出，可以使用这个identifier在程序重新启动是创建一个新的configuration和session关联之前传输。\n@property(readonly, copy) NSString  *identifier;\n\n//默认为空，NSURLRequest附件的请求头。\n//这个属性会给所有使用该configuration的session生成的tasks中的NSURLRequest添加额外的请求头。\n//如果这里边添加的请求头跟NSURLRequest中重复了，侧优先使用NSURLRequest中的头\n@property(copy) NSDictionary  *HTTPAdditionalHeaders;\n\n//是否使用蜂窝网络，默认是yes.\n@property BOOL allowsCellularAccess;\n\n//给request指定每次接收数据超时间隔\n//如果下一次接受新数据用时超过该值，则发送一个请求超时给该request。默认为60s\n@property NSTimeInterval  timeoutIntervalForRequest;\n\n//给指定resource设定一个超时时间，resource需要在时间到达之前完成\n//默认是7天。 \n@property NSTimeInterval  timeoutIntervalForResource;\n\n//discretionary属性为YES时表示当程序在后台运作时由系统自己选择最佳的网络连接配置，该属性可以节省通过蜂窝连接的带宽。\n//在使用后台传输数据的时候，建议使用discretionary属性，而不是allowsCellularAccess属性，因为它会把WiFi和电源可用性考虑在内。\n@property (getter=isDiscretionary) BOOL discretionary;\n\n//表示当后台传输结束时，是否启动app.这个属性只对 生效，其他configuration类型会自动忽略该值。默认值是YES。\n@property BOOL sessionSendsLaunchEvents;\n\n//是否启动通道，可以用于加快网络请求，默认是NO\n@property BOOL HTTPShouldUsePipelining;\n\n/===========储存的相关属性=============/\n\n//存储cookie，清除存储，直接set为nil即可。\n//对于默认和后台的session，使用sharedHTTPCookieStorage。\n//对于短暂的session，cookie仅仅储存到内存，session失效时会自动清除。\n@property(retain) NSHTTPCookieStorage  *HTTPCookieStorage;\n\n//默认为yes,是否提供来自shareCookieStorge的cookie\n//如果想要自己提供cookie，可以使用HTTPAdditionalHeaders来提供。\n@property BOOL  HTTPShouldSetCookies;\n\n//证书存储，如果不使用，可set为nil.\n//默认和后台session，默认使用的sharedCredentialStorage.\n//短暂的session使用一个私有存储在内存中。session失效会自动清除。\n@property(retain) NSURLCredentialStorage *URLCredentialStorage;\n\n//缓存NSURLRequest的response。\n//默认的configuration，默认值的是sharedURLCache。\n//后台的configuration，默认值是nil\n//短暂的configuration，默认一个私有的cache于内存，session失效，cache自动清除。\n@property(retain) NSURLCache  *URLCache;\n\n//缓存策略，用于设置该会话中的Request的cachePolicy，如果Request有单独设置的话，以Request为准。\n//默认值是NSURLRequestUseProtocolCachePolicy\n@property NSURLRequestCachePolicy requestCachePolicy;\n```\n\n## 3.NSURLSessionTask\n根据NSURLSession来创建task进行网络请求\n* NSURLSessionDataTask,可以用来处理一般的网络请求，如 GET | POST 请求等。\n* NSURLSessionUploadTask，用于处理上传请求。\n* NSURLSessionDownloadTask，主要用于处理下载请求。\n\n可以直接用异步回调的形式，也可以用代理的方式进行网络请求\n#### 缓存:\n\n```objc\ntypedef NS_ENUM(NSUInteger, NSURLRequestCachePolicy)\n{\n    //对特定的 URL 请求使用网络协议中实现的缓存逻辑。这是默认的策略。\n    NSURLRequestUseProtocolCachePolicy = 0,\n\n    //数据需要从原始地址加载。不使用现有缓存。\n    NSURLRequestReloadIgnoringLocalCacheData = 1,\n\n    // 不仅忽略本地缓存，同时也忽略代理服务器或其他中间介质目前已有的、协议允许的缓存。\n    NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4, \n\n    NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData,\n\n    //无论缓存是否过期，先使用本地缓存数据。如果缓存中没有请求所对应的数据，那么从原始地址加载数据。\n    NSURLRequestReturnCacheDataElseLoad = 2,\n\n    //无论缓存是否过期，先使用本地缓存数据。如果缓存中没有请求所对应的数据，那么放弃从原始地址加载数据，请求视为失败（即：“离线”模式）。\n    NSURLRequestReturnCacheDataDontLoad = 3,\n\n    //从原始地址确认缓存数据的合法性后，缓存数据就可以使用，否则从原始地址加载。\n    NSURLRequestReloadRevalidatingCacheData = 5, \n};\n```\n\n#### NSURLSessionDataTask\n\n```objc\n//这两个方法需要设置代理来接收数据\n- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request;\n- (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url;\n\n//这两个方法在completionHandler来接收数据\n- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler;\n- (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler;\n```\n\n```objc\n#import \"ViewController.h\"\n\n@interface ViewController () <NSURLSessionDelegate,NSURLSessionTaskDelegate>\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    [self sendRequest];\n}\n- (void)sendRequest{\n    //创建请求\n    NSURL *url = [NSURL URLWithString:@\"http://httpbin.org/get\"];\n    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];\n    //设置request的缓存策略（决定该request是否要从缓存中获取）\n    request.cachePolicy = NSURLRequestReturnCacheDataElseLoad;\n    \n    //创建配置（决定要不要将数据和响应缓存在磁盘）\n    NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];\n    //configuration.requestCachePolicy = NSURLRequestReturnCacheDataElseLoad;\n    \n    //创建会话\n    NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:nil];\n    //生成任务\n    NSURLSessionDataTask *task = [session dataTaskWithRequest:request];\n    //创建的task是停止状态，需要我们去启动\n    [task resume];\n}\n//1.接收到服务器响应的时候调用\n- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask\ndidReceiveResponse:(NSURLResponse *)response\n completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler{\n    NSLog(@\"接收响应\");\n    //必须告诉系统是否接收服务器返回的数据\n    //默认是completionHandler(NSURLSessionResponseAllow)\n    //可以再这边通过响应的statusCode来判断否接收服务器返回的数据\n    completionHandler(NSURLSessionResponseAllow);\n}\n//2.接受到服务器返回数据的时候调用,可能被调用多次\n- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data{\n    NSLog(@\"接收到数据\");\n    //一般在这边进行数据的拼接，在方法3才将完整数据回调\n//    NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil];\n}\n//3.请求完成或者是失败的时候调用\n- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task\ndidCompleteWithError:(nullable NSError *)error{\n    NSLog(@\"请求完成或者是失败\");\n    //在这边进行完整数据的解析，回调\n}\n//4.将要缓存响应的时候调用（必须是默认会话模式，GET请求才可以）\n- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask\n willCacheResponse:(NSCachedURLResponse *)proposedResponse\n completionHandler:(void (^)(NSCachedURLResponse * _Nullable cachedResponse))completionHandler{\n    //可以在这边更改是否缓存，默认的话是completionHandler(proposedResponse)\n    //不想缓存的话可以设置completionHandler(nil)\n    completionHandler(proposedResponse);\n}\n@end\n```\n\n```objc\nNSURL *url = [NSURL URLWithString:@\"http://www.connect.com/login\"];\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];\nrequest.HTTPMethod = @\"POST\";\nrequest.HTTPBody = [@\"username=Tom&pwd=123\" dataUsingEncoding:NSUTF8StringEncoding];\n\n//使用全局的会话\nNSURLSession *session = [NSURLSession sharedSession];\n// 通过request初始化task\nNSURLSessionTask *task = [session dataTaskWithRequest:request\n                                   completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) { \n    NSLog(@\"%@\", [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]);\n }];\n//创建的task是停止状态，需要我们去启动\n[task resume];\n```\n\n#### NSURLSessionUploadTask\n\n```objc\n/=========代理方式===========/\n//通过文件url来上传\n- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL;  \n//通过文件data来上传\n- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData;  \n//通过文件流来上传\n- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request;\n\n/=========Block方式===========/\n- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;  \n- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;\n```\n\n这三种上传方式分别针对什么应用场景呢？\n* NSData：如果对象已经在内存里\n* File：如果对象在磁盘上，这样做有助于降低内存使用\n* Stream：通过流对象，你可以不用一次性将所有的流数据加载到内存中\n不过使用Stream一定要实现URLSession:task:needNewBodyStream:，因为Session没办法在重新尝试发送Stream的时候找到数据源。\n\n```objc\n//上传图片\n- (void)uploadRequest{\n    //创建请求\n    NSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://www.freeimagehosting.net/upload.php\"]];\n    //如果是上传文字就是@\"application/json\"\n    [request addValue:@\"image/jpeg\" forHTTPHeaderField:@\"Content-Type\"];\n    [request addValue:@\"text/html\" forHTTPHeaderField:@\"Accept\"];\n    [request setHTTPMethod:@\"POST\"];\n    [request setCachePolicy:NSURLRequestReloadIgnoringCacheData];\n    [request setTimeoutInterval:20];\n    NSData * imagedata = UIImageJPEGRepresentation([UIImage imageNamed:@\"person\"],1.0);\n    \n    //创建配置（决定要不要将数据和响应缓存在磁盘）\n    NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];\n    //创建会话\n    NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:nil];\n    \n    NSURLSessionUploadTask * uploadtask = [session uploadTaskWithRequest:request fromData:imagedata completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n        //发送完成的回调\n        \n    }];\n    [uploadtask resume];\n}\n//发送数据过程中会执行(执行多次)\n-(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend{\n    NSLog(@\"发送数据中\");\n    //在这边监听发送的进度\n    //progress = totalBytesSent/(float)totalBytesExpectedToSend\n}\n```\n\n#### NSURLSessionDownloadTask\n\n* 下载文件可以实现断点下载\n* 内部已经完成了边接收数据边写入沙盒的操作（直接下载到磁盘）\n* 支持BackgroundSession（后台下载）\n\n使用NSURLSessionDownloadTask 下载文件的过程与前面差不多，需要注意的是文件下载文件之后会自动保存到一个临时目录(temp)，需要开发人员自己将此文件重新放到其他指定的目录中。 或者直接在内存里面显示, 默认异步的.NSURLSession 自动不会出现内存暴涨情况\n\n```objc\n/=========代理方式===========/\n- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request;  \n- (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url;  \n//通过之前已经下载的数据来创建下载任务\n- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData;  \n\n/=========Block方式===========/\n- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;  \n- (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;  \n- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;\n```\n\n```objc\n- (void)downloadRequest{\n    //创建请求\n    NSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://httpbin.org/image/jpeg\"]];\n    \n    //创建配置（决定要不要将数据和响应缓存在磁盘）\n    NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];\n    //创建会话\n    NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:nil];\n    \n    NSURLSessionDownloadTask * downloadtask = [session downloadTaskWithRequest:request];\n    [downloadtask resume];\n}\n\n//1. downloadTask下载过程中会执行\n- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite{\n    NSLog(@\"下载中...\");\n    NSLog(@\"写入数据大小%lld，总写入数据大小%lld，总期望数据大小%lld\",bytesWritten,totalBytesWritten,totalBytesExpectedToWrite);\n    //监听下载的进度\n}\n//2.downloadTask下载完成的时候会执行\n- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location{\n    NSLog(@\"下载完成\");\n       //该方法内部已经完成了边接收数据边写沙盒的操作，解决了内存飙升的问题\n    //对数据进行使用，或者保存（默认存储到临时文件夹 tmp 中，需要剪切文件到 cache）\n    \n    //保存\n    NSString *filePath = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:downloadTask.response.suggestedFilename];\n    [[NSFileManager defaultManager] moveItemAtURL:location toURL:[NSURL fileURLWithPath:filePath] error:nil];\n\n    //使用\n    NSData * data = [NSData dataWithContentsOfURL:location.filePathURL];\n    UIImage * image = [UIImage imageWithData:data];\n    UIImageWriteToSavedPhotosAlbum(image, nil,nil,nil);\n}\n//3.请求完成或者是失败的时候调用(Session层次的Task完成的事件)\n- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task\ndidCompleteWithError:(nullable NSError *)error{\n    NSLog(@\"请求完成或者是失败\");\n}\n```\n\n断点续传:\n\n```objc\n// 使用这种方式取消下载可以得到将来用来恢复的数据,保存起来\n[self.task cancelByProducingResumeData:^(NSData *resumeData) {\n    self.resumeData = resumeData;\n}];\n\n// 由于下载失败导致的下载中断会进入此协议方法,也可以得到用来恢复的数据\n- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error\n{\n    // 保存恢复数据\n    self.resumeData = error.userInfo[NSURLSessionDownloadTaskResumeData];\n}\n\n// 恢复下载时接过保存的恢复数据\nself.task = [self.session downloadTaskWithResumeData:self.resumeData];\n// 启动任务\n[self.task resume];\n```\n\n后台下载\n\n使用后台会话进行下程序退出到后台也能正常下载完成,但是程序在后台UI无法更新,不能获取进度;这时,我们需要通过应用程序代理进行UI更新,原理如图:\n\n![](/images/img1.png)\n\n当NSURLSession在后台开启几个任务之后,如果其中有任务完成,系统就会会调用此APP的代理方法:```- (void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifiercompletionHandler:(void (^)(void))completionHandler```里进行完成的操作. 通常我们会保持此对象,直到最后一个任务完成; \n此时会重新通过会话标识(config中设置的)找到对应会话并调用NSURLSession的```-(void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession * )session```代理方法例进行UI的更新.并调用completionHandler通知系统已经完成所有操作。具体如下:\n\n```objc\n-(void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler{\n\n    //backgroundSessionCompletionHandler是自定义的一个属性\n    self.backgroundSessionCompletionHandler=completionHandler;   \n}\n\n-(void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session{\n    AppDelegate *appDelegate = (AppDelegate *)[[UIApplication sharedApplication] delegate];\n\n    //Other Operation....\n\n    if (appDelegate.backgroundSessionCompletionHandler) {\n\n        void (^completionHandler)() = appDelegate.backgroundSessionCompletionHandler;     \n        appDelegate.backgroundSessionCompletionHandler = nil;        \n        completionHandler();\n    }\n}\n```\n\n使用GCD进行一次发起多个请求，全部完成后进行统一处理\n\n```objc\nlet group : dispatch_group_t = dispatch_group_create()\nlet queue : dispatch_queue_t = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)\n        \ndispatch_group_async(group, queue) { \n  dispatch_group_enter(group)\n  //发起第一个请求\n}\n\ndispatch_group_async(group, queue) {\n  dispatch_group_enter(group)\n  //发起第二个请求\n}\n\ndispatch_group_notify(group, queue) {\n  //全部完成后，进行统一处理\n}\n\n//每个请求完成时，调用dispatch_group_leave(group)\n```\n\n参考:</br>\nhttps://www.jianshu.com/p/a8fc22afb739\nhttp://blog.csdn.net/csdnhaoren13/article/details/50809506\n","slug":"NSURLSession","published":1,"updated":"2021-03-05T15:40:43.867Z","_id":"cklwcgyev0000pq5w8uok01nh","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-URL-Session-类体系\"><a href=\"#1-URL-Session-类体系\" class=\"headerlink\" title=\"1.URL Session 类体系\"></a>1.URL Session 类体系</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.NSURLSession ——会话类</span><br><span class=\"line\">2.NSURLSessionConfiguration ——会话配置</span><br><span class=\"line\">3.NSURLSessionTask——task抽象类</span><br><span class=\"line\">        - NSURLSessionDataTask——普通task类</span><br><span class=\"line\">            - NSRULSessionUploadTask——上传task类</span><br><span class=\"line\">        - NSURLSessionDownloadTask——下载task类</span><br><span class=\"line\">        - NSURLSessionStreamTask——流task类</span><br><span class=\"line\"></span><br><span class=\"line\">代理</span><br><span class=\"line\">NSURLSessionDelegate</span><br><span class=\"line\">NSURLSessionTaskDelegate</span><br><span class=\"line\">NSURLSessionDataDelegate</span><br><span class=\"line\">NSURLSessionDownloadDelegate</span><br><span class=\"line\">NSURLSessionStreamDelegate</span><br><span class=\"line\"></span><br><span class=\"line\">其他</span><br><span class=\"line\">NSURL</span><br><span class=\"line\">NSURLRequest</span><br><span class=\"line\">NSURLResponse</span><br><span class=\"line\">    - NSHTTPURLResponse</span><br><span class=\"line\">NSCachedURLResponse</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-NSURLSessionConfiguration\"><a href=\"#2-NSURLSessionConfiguration\" class=\"headerlink\" title=\"2.NSURLSessionConfiguration\"></a>2.NSURLSessionConfiguration</h2><p>NSURLSession可以通过sharedSession创建，也可以通过NSURLSessionConfiguration来创建。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用静态的sharedSession方法，该类使用共享的会话，该会话使用全局的Cache，Cookie和证书</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)sharedSession;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过sessionWithConfiguration:方法创建对象，也就是创建对应配置的会话，与NSURLSessionConfiguration合作使用</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)sessionWithConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过设置配置、代理、队列来创建会话对象</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)sessionWithConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration delegate:(<span class=\"keyword\">id</span> &lt;<span class=\"built_in\">NSURLSessionDelegate</span>&gt;)delegate delegateQueue:(<span class=\"built_in\">NSOperationQueue</span> *)queue;</span><br></pre></td></tr></table></figure>\n<p>NSURLSessionConfiguration其实是对NSURLSession的配置。<br>NSURLSession有以下三种模式，分别对应NSURLSessionConfiguration的三种创建模式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSURLSessionConfiguration</span> *)defaultSessionConfiguration;  </span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLSessionConfiguration</span> *)ephemeralSessionConfiguration;  </span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLSessionConfiguration</span> *)backgroundSessionConfiguration:(<span class=\"built_in\">NSString</span> *)identifier;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>默认会话模式（default）：工作模式类似于原来的NSURLConnection，使用的是基于磁盘缓存的持久化策略，使用用户keychain中保存的证书进行认证授权。</li>\n<li>瞬时会话模式（ephemeral）：该模式不使用磁盘保存任何数据。所有和会话相关的caches，证书，cookies等都被保存在RAM中，因此当程序使会话无效，这些缓存的数据就会被自动清空。（可以实现私密浏览）</li>\n<li>后台会话模式（background）：该模式在后台完成上传和下载（在系统的一个单独的进程中执行），在创建Configuration对象的时候需要提供一个NSString类型的ID用于标识完成工作的后台会话。</li>\n</ul>\n<p>NSURLSessionConfiguration各个属性的设置:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如果在后台任务正在传输时程序退出，可以使用这个identifier在程序重新启动是创建一个新的configuration和session关联之前传输。</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">readonly</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span>  *identifier;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//默认为空，NSURLRequest附件的请求头。</span></span><br><span class=\"line\"><span class=\"comment\">//这个属性会给所有使用该configuration的session生成的tasks中的NSURLRequest添加额外的请求头。</span></span><br><span class=\"line\"><span class=\"comment\">//如果这里边添加的请求头跟NSURLRequest中重复了，侧优先使用NSURLRequest中的头</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">copy</span>) <span class=\"built_in\">NSDictionary</span>  *HTTPAdditionalHeaders;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//是否使用蜂窝网络，默认是yes.</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">BOOL</span> allowsCellularAccess;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//给request指定每次接收数据超时间隔</span></span><br><span class=\"line\"><span class=\"comment\">//如果下一次接受新数据用时超过该值，则发送一个请求超时给该request。默认为60s</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSTimeInterval</span>  timeoutIntervalForRequest;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//给指定resource设定一个超时时间，resource需要在时间到达之前完成</span></span><br><span class=\"line\"><span class=\"comment\">//默认是7天。 </span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSTimeInterval</span>  timeoutIntervalForResource;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//discretionary属性为YES时表示当程序在后台运作时由系统自己选择最佳的网络连接配置，该属性可以节省通过蜂窝连接的带宽。</span></span><br><span class=\"line\"><span class=\"comment\">//在使用后台传输数据的时候，建议使用discretionary属性，而不是allowsCellularAccess属性，因为它会把WiFi和电源可用性考虑在内。</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">getter</span>=isDiscretionary) <span class=\"built_in\">BOOL</span> discretionary;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//表示当后台传输结束时，是否启动app.这个属性只对 生效，其他configuration类型会自动忽略该值。默认值是YES。</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">BOOL</span> sessionSendsLaunchEvents;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//是否启动通道，可以用于加快网络请求，默认是NO</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">BOOL</span> HTTPShouldUsePipelining;</span><br><span class=\"line\"></span><br><span class=\"line\">/===========储存的相关属性=============/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//存储cookie，清除存储，直接set为nil即可。</span></span><br><span class=\"line\"><span class=\"comment\">//对于默认和后台的session，使用sharedHTTPCookieStorage。</span></span><br><span class=\"line\"><span class=\"comment\">//对于短暂的session，cookie仅仅储存到内存，session失效时会自动清除。</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">retain</span>) <span class=\"built_in\">NSHTTPCookieStorage</span>  *HTTPCookieStorage;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//默认为yes,是否提供来自shareCookieStorge的cookie</span></span><br><span class=\"line\"><span class=\"comment\">//如果想要自己提供cookie，可以使用HTTPAdditionalHeaders来提供。</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">BOOL</span>  HTTPShouldSetCookies;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//证书存储，如果不使用，可set为nil.</span></span><br><span class=\"line\"><span class=\"comment\">//默认和后台session，默认使用的sharedCredentialStorage.</span></span><br><span class=\"line\"><span class=\"comment\">//短暂的session使用一个私有存储在内存中。session失效会自动清除。</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">retain</span>) <span class=\"built_in\">NSURLCredentialStorage</span> *URLCredentialStorage;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//缓存NSURLRequest的response。</span></span><br><span class=\"line\"><span class=\"comment\">//默认的configuration，默认值的是sharedURLCache。</span></span><br><span class=\"line\"><span class=\"comment\">//后台的configuration，默认值是nil</span></span><br><span class=\"line\"><span class=\"comment\">//短暂的configuration，默认一个私有的cache于内存，session失效，cache自动清除。</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">retain</span>) <span class=\"built_in\">NSURLCache</span>  *URLCache;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//缓存策略，用于设置该会话中的Request的cachePolicy，如果Request有单独设置的话，以Request为准。</span></span><br><span class=\"line\"><span class=\"comment\">//默认值是NSURLRequestUseProtocolCachePolicy</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSURLRequestCachePolicy</span> requestCachePolicy;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-NSURLSessionTask\"><a href=\"#3-NSURLSessionTask\" class=\"headerlink\" title=\"3.NSURLSessionTask\"></a>3.NSURLSessionTask</h2><p>根据NSURLSession来创建task进行网络请求</p>\n<ul>\n<li>NSURLSessionDataTask,可以用来处理一般的网络请求，如 GET | POST 请求等。</li>\n<li>NSURLSessionUploadTask，用于处理上传请求。</li>\n<li>NSURLSessionDownloadTask，主要用于处理下载请求。</li>\n</ul>\n<p>可以直接用异步回调的形式，也可以用代理的方式进行网络请求</p>\n<h4 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存:\"></a>缓存:</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSUInteger</span>, <span class=\"built_in\">NSURLRequestCachePolicy</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//对特定的 URL 请求使用网络协议中实现的缓存逻辑。这是默认的策略。</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLRequestUseProtocolCachePolicy</span> = <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//数据需要从原始地址加载。不使用现有缓存。</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLRequestReloadIgnoringLocalCacheData</span> = <span class=\"number\">1</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 不仅忽略本地缓存，同时也忽略代理服务器或其他中间介质目前已有的、协议允许的缓存。</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLRequestReloadIgnoringLocalAndRemoteCacheData</span> = <span class=\"number\">4</span>, </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSURLRequestReloadIgnoringCacheData</span> = <span class=\"built_in\">NSURLRequestReloadIgnoringLocalCacheData</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//无论缓存是否过期，先使用本地缓存数据。如果缓存中没有请求所对应的数据，那么从原始地址加载数据。</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLRequestReturnCacheDataElseLoad</span> = <span class=\"number\">2</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//无论缓存是否过期，先使用本地缓存数据。如果缓存中没有请求所对应的数据，那么放弃从原始地址加载数据，请求视为失败（即：“离线”模式）。</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLRequestReturnCacheDataDontLoad</span> = <span class=\"number\">3</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//从原始地址确认缓存数据的合法性后，缓存数据就可以使用，否则从原始地址加载。</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLRequestReloadRevalidatingCacheData</span> = <span class=\"number\">5</span>, </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"NSURLSessionDataTask\"><a href=\"#NSURLSessionDataTask\" class=\"headerlink\" title=\"NSURLSessionDataTask\"></a>NSURLSessionDataTask</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这两个方法需要设置代理来接收数据</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request;</span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTaskWithURL:(<span class=\"built_in\">NSURL</span> *)url;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这两个方法在completionHandler来接收数据</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSData</span> * _Nullable data, <span class=\"built_in\">NSURLResponse</span> * _Nullable response, <span class=\"built_in\">NSError</span> * _Nullable error))completionHandler;</span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTaskWithURL:(<span class=\"built_in\">NSURL</span> *)url completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSData</span> * _Nullable data, <span class=\"built_in\">NSURLResponse</span> * _Nullable response, <span class=\"built_in\">NSError</span> * _Nullable error))completionHandler;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&quot;ViewController.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> () &lt;<span class=\"title\">NSURLSessionDelegate</span>,<span class=\"title\">NSURLSessionTaskDelegate</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"comment\">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> sendRequest];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)sendRequest&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建请求</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *url = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@&quot;http://httpbin.org/get&quot;</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableURLRequest</span> *request = [<span class=\"built_in\">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class=\"line\">    <span class=\"comment\">//设置request的缓存策略（决定该request是否要从缓存中获取）</span></span><br><span class=\"line\">    request.cachePolicy = <span class=\"built_in\">NSURLRequestReturnCacheDataElseLoad</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建配置（决定要不要将数据和响应缓存在磁盘）</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">    <span class=\"comment\">//configuration.requestCachePolicy = NSURLRequestReturnCacheDataElseLoad;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建会话</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSession</span> *session = [<span class=\"built_in\">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class=\"keyword\">self</span> delegateQueue:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"comment\">//生成任务</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request];</span><br><span class=\"line\">    <span class=\"comment\">//创建的task是停止状态，需要我们去启动</span></span><br><span class=\"line\">    [task resume];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//1.接收到服务器响应的时候调用</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session dataTask:(<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTask</span><br><span class=\"line\">didReceiveResponse:(<span class=\"built_in\">NSURLResponse</span> *)response</span><br><span class=\"line\"> completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSURLSessionResponseDisposition</span> disposition))completionHandler&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;接收响应&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//必须告诉系统是否接收服务器返回的数据</span></span><br><span class=\"line\">    <span class=\"comment\">//默认是completionHandler(NSURLSessionResponseAllow)</span></span><br><span class=\"line\">    <span class=\"comment\">//可以再这边通过响应的statusCode来判断否接收服务器返回的数据</span></span><br><span class=\"line\">    completionHandler(<span class=\"built_in\">NSURLSessionResponseAllow</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//2.接受到服务器返回数据的时候调用,可能被调用多次</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session dataTask:(<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class=\"built_in\">NSData</span> *)data&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;接收到数据&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//一般在这边进行数据的拼接，在方法3才将完整数据回调</span></span><br><span class=\"line\"><span class=\"comment\">//    NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil];</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//3.请求完成或者是失败的时候调用</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session task:(<span class=\"built_in\">NSURLSessionTask</span> *)task</span><br><span class=\"line\">didCompleteWithError:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSError</span> *)error&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;请求完成或者是失败&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//在这边进行完整数据的解析，回调</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//4.将要缓存响应的时候调用（必须是默认会话模式，GET请求才可以）</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session dataTask:(<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTask</span><br><span class=\"line\"> willCacheResponse:(<span class=\"built_in\">NSCachedURLResponse</span> *)proposedResponse</span><br><span class=\"line\"> completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSCachedURLResponse</span> * _Nullable cachedResponse))completionHandler&#123;</span><br><span class=\"line\">    <span class=\"comment\">//可以在这边更改是否缓存，默认的话是completionHandler(proposedResponse)</span></span><br><span class=\"line\">    <span class=\"comment\">//不想缓存的话可以设置completionHandler(nil)</span></span><br><span class=\"line\">    completionHandler(proposedResponse);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURL</span> *url = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@&quot;http://www.connect.com/login&quot;</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSMutableURLRequest</span> *request = [<span class=\"built_in\">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class=\"line\">request.HTTPMethod = <span class=\"string\">@&quot;POST&quot;</span>;</span><br><span class=\"line\">request.HTTPBody = [<span class=\"string\">@&quot;username=Tom&amp;pwd=123&quot;</span> dataUsingEncoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用全局的会话</span></span><br><span class=\"line\"><span class=\"built_in\">NSURLSession</span> *session = [<span class=\"built_in\">NSURLSession</span> sharedSession];</span><br><span class=\"line\"><span class=\"comment\">// 通过request初始化task</span></span><br><span class=\"line\"><span class=\"built_in\">NSURLSessionTask</span> *task = [session dataTaskWithRequest:request</span><br><span class=\"line\">                                   completionHandler:^(<span class=\"built_in\">NSData</span> *data, <span class=\"built_in\">NSURLResponse</span> *response, <span class=\"built_in\">NSError</span> *error) &#123; </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@&quot;</span>, [<span class=\"built_in\">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:<span class=\"literal\">nil</span>]);</span><br><span class=\"line\"> &#125;];</span><br><span class=\"line\"><span class=\"comment\">//创建的task是停止状态，需要我们去启动</span></span><br><span class=\"line\">[task resume];</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"NSURLSessionUploadTask\"><a href=\"#NSURLSessionUploadTask\" class=\"headerlink\" title=\"NSURLSessionUploadTask\"></a>NSURLSessionUploadTask</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/=========代理方式===========/</span><br><span class=\"line\"><span class=\"comment\">//通过文件url来上传</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request fromFile:(<span class=\"built_in\">NSURL</span> *)fileURL;  </span><br><span class=\"line\"><span class=\"comment\">//通过文件data来上传</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request fromData:(<span class=\"built_in\">NSData</span> *)bodyData;  </span><br><span class=\"line\"><span class=\"comment\">//通过文件流来上传</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionUploadTask</span> *)uploadTaskWithStreamedRequest:(<span class=\"built_in\">NSURLRequest</span> *)request;</span><br><span class=\"line\"></span><br><span class=\"line\">/=========Block方式===========/</span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request fromFile:(<span class=\"built_in\">NSURL</span> *)fileURL completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSData</span> *data, <span class=\"built_in\">NSURLResponse</span> *response, <span class=\"built_in\">NSError</span> *error))completionHandler;  </span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request fromData:(<span class=\"built_in\">NSData</span> *)bodyData completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSData</span> *data, <span class=\"built_in\">NSURLResponse</span> *response, <span class=\"built_in\">NSError</span> *error))completionHandler;</span><br></pre></td></tr></table></figure>\n\n<p>这三种上传方式分别针对什么应用场景呢？</p>\n<ul>\n<li>NSData：如果对象已经在内存里</li>\n<li>File：如果对象在磁盘上，这样做有助于降低内存使用</li>\n<li>Stream：通过流对象，你可以不用一次性将所有的流数据加载到内存中<br>不过使用Stream一定要实现URLSession:task:needNewBodyStream:，因为Session没办法在重新尝试发送Stream的时候找到数据源。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//上传图片</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)uploadRequest&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建请求</span></span><br><span class=\"line\">    <span class=\"built_in\">NSMutableURLRequest</span> * request = [<span class=\"built_in\">NSMutableURLRequest</span> requestWithURL:[<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@&quot;http://www.freeimagehosting.net/upload.php&quot;</span>]];</span><br><span class=\"line\">    <span class=\"comment\">//如果是上传文字就是@&quot;application/json&quot;</span></span><br><span class=\"line\">    [request addValue:<span class=\"string\">@&quot;image/jpeg&quot;</span> forHTTPHeaderField:<span class=\"string\">@&quot;Content-Type&quot;</span>];</span><br><span class=\"line\">    [request addValue:<span class=\"string\">@&quot;text/html&quot;</span> forHTTPHeaderField:<span class=\"string\">@&quot;Accept&quot;</span>];</span><br><span class=\"line\">    [request setHTTPMethod:<span class=\"string\">@&quot;POST&quot;</span>];</span><br><span class=\"line\">    [request setCachePolicy:<span class=\"built_in\">NSURLRequestReloadIgnoringCacheData</span>];</span><br><span class=\"line\">    [request setTimeoutInterval:<span class=\"number\">20</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSData</span> * imagedata = <span class=\"built_in\">UIImageJPEGRepresentation</span>([<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@&quot;person&quot;</span>],<span class=\"number\">1.0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建配置（决定要不要将数据和响应缓存在磁盘）</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">    <span class=\"comment\">//创建会话</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSession</span> *session = [<span class=\"built_in\">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class=\"keyword\">self</span> delegateQueue:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionUploadTask</span> * uploadtask = [session uploadTaskWithRequest:request fromData:imagedata completionHandler:^(<span class=\"built_in\">NSData</span> *data, <span class=\"built_in\">NSURLResponse</span> *response, <span class=\"built_in\">NSError</span> *error) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//发送完成的回调</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    [uploadtask resume];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//发送数据过程中会执行(执行多次)</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session task:(<span class=\"built_in\">NSURLSessionTask</span> *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;发送数据中&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//在这边监听发送的进度</span></span><br><span class=\"line\">    <span class=\"comment\">//progress = totalBytesSent/(float)totalBytesExpectedToSend</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"NSURLSessionDownloadTask\"><a href=\"#NSURLSessionDownloadTask\" class=\"headerlink\" title=\"NSURLSessionDownloadTask\"></a>NSURLSessionDownloadTask</h4><ul>\n<li>下载文件可以实现断点下载</li>\n<li>内部已经完成了边接收数据边写入沙盒的操作（直接下载到磁盘）</li>\n<li>支持BackgroundSession（后台下载）</li>\n</ul>\n<p>使用NSURLSessionDownloadTask 下载文件的过程与前面差不多，需要注意的是文件下载文件之后会自动保存到一个临时目录(temp)，需要开发人员自己将此文件重新放到其他指定的目录中。 或者直接在内存里面显示, 默认异步的.NSURLSession 自动不会出现内存暴涨情况</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/=========代理方式===========/</span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request;  </span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDownloadTask</span> *)downloadTaskWithURL:(<span class=\"built_in\">NSURL</span> *)url;  </span><br><span class=\"line\"><span class=\"comment\">//通过之前已经下载的数据来创建下载任务</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDownloadTask</span> *)downloadTaskWithResumeData:(<span class=\"built_in\">NSData</span> *)resumeData;  </span><br><span class=\"line\"></span><br><span class=\"line\">/=========Block方式===========/</span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSURL</span> *location, <span class=\"built_in\">NSURLResponse</span> *response, <span class=\"built_in\">NSError</span> *error))completionHandler;  </span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDownloadTask</span> *)downloadTaskWithURL:(<span class=\"built_in\">NSURL</span> *)url completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSURL</span> *location, <span class=\"built_in\">NSURLResponse</span> *response, <span class=\"built_in\">NSError</span> *error))completionHandler;  </span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDownloadTask</span> *)downloadTaskWithResumeData:(<span class=\"built_in\">NSData</span> *)resumeData completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSURL</span> *location, <span class=\"built_in\">NSURLResponse</span> *response, <span class=\"built_in\">NSError</span> *error))completionHandler;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)downloadRequest&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建请求</span></span><br><span class=\"line\">    <span class=\"built_in\">NSMutableURLRequest</span> * request = [<span class=\"built_in\">NSMutableURLRequest</span> requestWithURL:[<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@&quot;http://httpbin.org/image/jpeg&quot;</span>]];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建配置（决定要不要将数据和响应缓存在磁盘）</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">    <span class=\"comment\">//创建会话</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSession</span> *session = [<span class=\"built_in\">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class=\"keyword\">self</span> delegateQueue:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionDownloadTask</span> * downloadtask = [session downloadTaskWithRequest:request];</span><br><span class=\"line\">    [downloadtask resume];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1. downloadTask下载过程中会执行</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session downloadTask:(<span class=\"built_in\">NSURLSessionDownloadTask</span> *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;下载中...&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;写入数据大小%lld，总写入数据大小%lld，总期望数据大小%lld&quot;</span>,bytesWritten,totalBytesWritten,totalBytesExpectedToWrite);</span><br><span class=\"line\">    <span class=\"comment\">//监听下载的进度</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//2.downloadTask下载完成的时候会执行</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session downloadTask:(<span class=\"built_in\">NSURLSessionDownloadTask</span> *)downloadTask didFinishDownloadingToURL:(<span class=\"built_in\">NSURL</span> *)location&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;下载完成&quot;</span>);</span><br><span class=\"line\">       <span class=\"comment\">//该方法内部已经完成了边接收数据边写沙盒的操作，解决了内存飙升的问题</span></span><br><span class=\"line\">    <span class=\"comment\">//对数据进行使用，或者保存（默认存储到临时文件夹 tmp 中，需要剪切文件到 cache）</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//保存</span></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *filePath = [[<span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSCachesDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>) lastObject] stringByAppendingPathComponent:downloadTask.response.suggestedFilename];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSFileManager</span> defaultManager] moveItemAtURL:location toURL:[<span class=\"built_in\">NSURL</span> fileURLWithPath:filePath] error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//使用</span></span><br><span class=\"line\">    <span class=\"built_in\">NSData</span> * data = [<span class=\"built_in\">NSData</span> dataWithContentsOfURL:location.filePathURL];</span><br><span class=\"line\">    <span class=\"built_in\">UIImage</span> * image = [<span class=\"built_in\">UIImage</span> imageWithData:data];</span><br><span class=\"line\">    <span class=\"built_in\">UIImageWriteToSavedPhotosAlbum</span>(image, <span class=\"literal\">nil</span>,<span class=\"literal\">nil</span>,<span class=\"literal\">nil</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//3.请求完成或者是失败的时候调用(Session层次的Task完成的事件)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session task:(<span class=\"built_in\">NSURLSessionTask</span> *)task</span><br><span class=\"line\">didCompleteWithError:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSError</span> *)error&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;请求完成或者是失败&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>断点续传:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用这种方式取消下载可以得到将来用来恢复的数据,保存起来</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.task cancelByProducingResumeData:^(<span class=\"built_in\">NSData</span> *resumeData) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.resumeData = resumeData;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 由于下载失败导致的下载中断会进入此协议方法,也可以得到用来恢复的数据</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session task:(<span class=\"built_in\">NSURLSessionTask</span> *)task didCompleteWithError:(<span class=\"built_in\">NSError</span> *)error</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 保存恢复数据</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.resumeData = error.userInfo[<span class=\"built_in\">NSURLSessionDownloadTaskResumeData</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 恢复下载时接过保存的恢复数据</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.task = [<span class=\"keyword\">self</span>.session downloadTaskWithResumeData:<span class=\"keyword\">self</span>.resumeData];</span><br><span class=\"line\"><span class=\"comment\">// 启动任务</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.task resume];</span><br></pre></td></tr></table></figure>\n\n<p>后台下载</p>\n<p>使用后台会话进行下程序退出到后台也能正常下载完成,但是程序在后台UI无法更新,不能获取进度;这时,我们需要通过应用程序代理进行UI更新,原理如图:</p>\n<p><img src=\"/images/img1.png\"></p>\n<p>当NSURLSession在后台开启几个任务之后,如果其中有任务完成,系统就会会调用此APP的代理方法:<code>- (void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifiercompletionHandler:(void (^)(void))completionHandler</code>里进行完成的操作. 通常我们会保持此对象,直到最后一个任务完成;<br>此时会重新通过会话标识(config中设置的)找到对应会话并调用NSURLSession的<code>-(void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession * )session</code>代理方法例进行UI的更新.并调用completionHandler通知系统已经完成所有操作。具体如下:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">void</span>)application:(<span class=\"built_in\">UIApplication</span> *)application handleEventsForBackgroundURLSession:(<span class=\"built_in\">NSString</span> *)identifier completionHandler:(<span class=\"keyword\">void</span> (^)())completionHandler&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//backgroundSessionCompletionHandler是自定义的一个属性</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.backgroundSessionCompletionHandler=completionHandler;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)URLSessionDidFinishEventsForBackgroundURLSession:(<span class=\"built_in\">NSURLSession</span> *)session&#123;</span><br><span class=\"line\">    AppDelegate *appDelegate = (AppDelegate *)[[<span class=\"built_in\">UIApplication</span> sharedApplication] delegate];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Other Operation....</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (appDelegate.backgroundSessionCompletionHandler) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">void</span> (^completionHandler)() = appDelegate.backgroundSessionCompletionHandler;     </span><br><span class=\"line\">        appDelegate.backgroundSessionCompletionHandler = <span class=\"literal\">nil</span>;        </span><br><span class=\"line\">        completionHandler();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用GCD进行一次发起多个请求，全部完成后进行统一处理</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let group : dispatch_group_t = dispatch_group_create()</span><br><span class=\"line\">let queue : <span class=\"built_in\">dispatch_queue_t</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">dispatch_group_async(group, queue) &#123; </span><br><span class=\"line\">  dispatch_group_enter(group)</span><br><span class=\"line\">  <span class=\"comment\">//发起第一个请求</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_group_async(group, queue) &#123;</span><br><span class=\"line\">  dispatch_group_enter(group)</span><br><span class=\"line\">  <span class=\"comment\">//发起第二个请求</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_group_notify(group, queue) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//全部完成后，进行统一处理</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//每个请求完成时，调用dispatch_group_leave(group)</span></span><br></pre></td></tr></table></figure>\n\n<p>参考:</br><br><a href=\"https://www.jianshu.com/p/a8fc22afb739\">https://www.jianshu.com/p/a8fc22afb739</a><br><a href=\"http://blog.csdn.net/csdnhaoren13/article/details/50809506\">http://blog.csdn.net/csdnhaoren13/article/details/50809506</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-URL-Session-类体系\"><a href=\"#1-URL-Session-类体系\" class=\"headerlink\" title=\"1.URL Session 类体系\"></a>1.URL Session 类体系</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.NSURLSession ——会话类</span><br><span class=\"line\">2.NSURLSessionConfiguration ——会话配置</span><br><span class=\"line\">3.NSURLSessionTask——task抽象类</span><br><span class=\"line\">        - NSURLSessionDataTask——普通task类</span><br><span class=\"line\">            - NSRULSessionUploadTask——上传task类</span><br><span class=\"line\">        - NSURLSessionDownloadTask——下载task类</span><br><span class=\"line\">        - NSURLSessionStreamTask——流task类</span><br><span class=\"line\"></span><br><span class=\"line\">代理</span><br><span class=\"line\">NSURLSessionDelegate</span><br><span class=\"line\">NSURLSessionTaskDelegate</span><br><span class=\"line\">NSURLSessionDataDelegate</span><br><span class=\"line\">NSURLSessionDownloadDelegate</span><br><span class=\"line\">NSURLSessionStreamDelegate</span><br><span class=\"line\"></span><br><span class=\"line\">其他</span><br><span class=\"line\">NSURL</span><br><span class=\"line\">NSURLRequest</span><br><span class=\"line\">NSURLResponse</span><br><span class=\"line\">    - NSHTTPURLResponse</span><br><span class=\"line\">NSCachedURLResponse</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-NSURLSessionConfiguration\"><a href=\"#2-NSURLSessionConfiguration\" class=\"headerlink\" title=\"2.NSURLSessionConfiguration\"></a>2.NSURLSessionConfiguration</h2><p>NSURLSession可以通过sharedSession创建，也可以通过NSURLSessionConfiguration来创建。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用静态的sharedSession方法，该类使用共享的会话，该会话使用全局的Cache，Cookie和证书</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)sharedSession;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过sessionWithConfiguration:方法创建对象，也就是创建对应配置的会话，与NSURLSessionConfiguration合作使用</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)sessionWithConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过设置配置、代理、队列来创建会话对象</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)sessionWithConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration delegate:(<span class=\"keyword\">id</span> &lt;<span class=\"built_in\">NSURLSessionDelegate</span>&gt;)delegate delegateQueue:(<span class=\"built_in\">NSOperationQueue</span> *)queue;</span><br></pre></td></tr></table></figure>\n<p>NSURLSessionConfiguration其实是对NSURLSession的配置。<br>NSURLSession有以下三种模式，分别对应NSURLSessionConfiguration的三种创建模式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSURLSessionConfiguration</span> *)defaultSessionConfiguration;  </span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLSessionConfiguration</span> *)ephemeralSessionConfiguration;  </span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLSessionConfiguration</span> *)backgroundSessionConfiguration:(<span class=\"built_in\">NSString</span> *)identifier;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>默认会话模式（default）：工作模式类似于原来的NSURLConnection，使用的是基于磁盘缓存的持久化策略，使用用户keychain中保存的证书进行认证授权。</li>\n<li>瞬时会话模式（ephemeral）：该模式不使用磁盘保存任何数据。所有和会话相关的caches，证书，cookies等都被保存在RAM中，因此当程序使会话无效，这些缓存的数据就会被自动清空。（可以实现私密浏览）</li>\n<li>后台会话模式（background）：该模式在后台完成上传和下载（在系统的一个单独的进程中执行），在创建Configuration对象的时候需要提供一个NSString类型的ID用于标识完成工作的后台会话。</li>\n</ul>\n<p>NSURLSessionConfiguration各个属性的设置:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如果在后台任务正在传输时程序退出，可以使用这个identifier在程序重新启动是创建一个新的configuration和session关联之前传输。</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">readonly</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span>  *identifier;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//默认为空，NSURLRequest附件的请求头。</span></span><br><span class=\"line\"><span class=\"comment\">//这个属性会给所有使用该configuration的session生成的tasks中的NSURLRequest添加额外的请求头。</span></span><br><span class=\"line\"><span class=\"comment\">//如果这里边添加的请求头跟NSURLRequest中重复了，侧优先使用NSURLRequest中的头</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">copy</span>) <span class=\"built_in\">NSDictionary</span>  *HTTPAdditionalHeaders;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//是否使用蜂窝网络，默认是yes.</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">BOOL</span> allowsCellularAccess;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//给request指定每次接收数据超时间隔</span></span><br><span class=\"line\"><span class=\"comment\">//如果下一次接受新数据用时超过该值，则发送一个请求超时给该request。默认为60s</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSTimeInterval</span>  timeoutIntervalForRequest;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//给指定resource设定一个超时时间，resource需要在时间到达之前完成</span></span><br><span class=\"line\"><span class=\"comment\">//默认是7天。 </span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSTimeInterval</span>  timeoutIntervalForResource;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//discretionary属性为YES时表示当程序在后台运作时由系统自己选择最佳的网络连接配置，该属性可以节省通过蜂窝连接的带宽。</span></span><br><span class=\"line\"><span class=\"comment\">//在使用后台传输数据的时候，建议使用discretionary属性，而不是allowsCellularAccess属性，因为它会把WiFi和电源可用性考虑在内。</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">getter</span>=isDiscretionary) <span class=\"built_in\">BOOL</span> discretionary;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//表示当后台传输结束时，是否启动app.这个属性只对 生效，其他configuration类型会自动忽略该值。默认值是YES。</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">BOOL</span> sessionSendsLaunchEvents;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//是否启动通道，可以用于加快网络请求，默认是NO</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">BOOL</span> HTTPShouldUsePipelining;</span><br><span class=\"line\"></span><br><span class=\"line\">/===========储存的相关属性=============/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//存储cookie，清除存储，直接set为nil即可。</span></span><br><span class=\"line\"><span class=\"comment\">//对于默认和后台的session，使用sharedHTTPCookieStorage。</span></span><br><span class=\"line\"><span class=\"comment\">//对于短暂的session，cookie仅仅储存到内存，session失效时会自动清除。</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">retain</span>) <span class=\"built_in\">NSHTTPCookieStorage</span>  *HTTPCookieStorage;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//默认为yes,是否提供来自shareCookieStorge的cookie</span></span><br><span class=\"line\"><span class=\"comment\">//如果想要自己提供cookie，可以使用HTTPAdditionalHeaders来提供。</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">BOOL</span>  HTTPShouldSetCookies;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//证书存储，如果不使用，可set为nil.</span></span><br><span class=\"line\"><span class=\"comment\">//默认和后台session，默认使用的sharedCredentialStorage.</span></span><br><span class=\"line\"><span class=\"comment\">//短暂的session使用一个私有存储在内存中。session失效会自动清除。</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">retain</span>) <span class=\"built_in\">NSURLCredentialStorage</span> *URLCredentialStorage;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//缓存NSURLRequest的response。</span></span><br><span class=\"line\"><span class=\"comment\">//默认的configuration，默认值的是sharedURLCache。</span></span><br><span class=\"line\"><span class=\"comment\">//后台的configuration，默认值是nil</span></span><br><span class=\"line\"><span class=\"comment\">//短暂的configuration，默认一个私有的cache于内存，session失效，cache自动清除。</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">retain</span>) <span class=\"built_in\">NSURLCache</span>  *URLCache;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//缓存策略，用于设置该会话中的Request的cachePolicy，如果Request有单独设置的话，以Request为准。</span></span><br><span class=\"line\"><span class=\"comment\">//默认值是NSURLRequestUseProtocolCachePolicy</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSURLRequestCachePolicy</span> requestCachePolicy;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-NSURLSessionTask\"><a href=\"#3-NSURLSessionTask\" class=\"headerlink\" title=\"3.NSURLSessionTask\"></a>3.NSURLSessionTask</h2><p>根据NSURLSession来创建task进行网络请求</p>\n<ul>\n<li>NSURLSessionDataTask,可以用来处理一般的网络请求，如 GET | POST 请求等。</li>\n<li>NSURLSessionUploadTask，用于处理上传请求。</li>\n<li>NSURLSessionDownloadTask，主要用于处理下载请求。</li>\n</ul>\n<p>可以直接用异步回调的形式，也可以用代理的方式进行网络请求</p>\n<h4 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存:\"></a>缓存:</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSUInteger</span>, <span class=\"built_in\">NSURLRequestCachePolicy</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//对特定的 URL 请求使用网络协议中实现的缓存逻辑。这是默认的策略。</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLRequestUseProtocolCachePolicy</span> = <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//数据需要从原始地址加载。不使用现有缓存。</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLRequestReloadIgnoringLocalCacheData</span> = <span class=\"number\">1</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 不仅忽略本地缓存，同时也忽略代理服务器或其他中间介质目前已有的、协议允许的缓存。</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLRequestReloadIgnoringLocalAndRemoteCacheData</span> = <span class=\"number\">4</span>, </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSURLRequestReloadIgnoringCacheData</span> = <span class=\"built_in\">NSURLRequestReloadIgnoringLocalCacheData</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//无论缓存是否过期，先使用本地缓存数据。如果缓存中没有请求所对应的数据，那么从原始地址加载数据。</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLRequestReturnCacheDataElseLoad</span> = <span class=\"number\">2</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//无论缓存是否过期，先使用本地缓存数据。如果缓存中没有请求所对应的数据，那么放弃从原始地址加载数据，请求视为失败（即：“离线”模式）。</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLRequestReturnCacheDataDontLoad</span> = <span class=\"number\">3</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//从原始地址确认缓存数据的合法性后，缓存数据就可以使用，否则从原始地址加载。</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLRequestReloadRevalidatingCacheData</span> = <span class=\"number\">5</span>, </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"NSURLSessionDataTask\"><a href=\"#NSURLSessionDataTask\" class=\"headerlink\" title=\"NSURLSessionDataTask\"></a>NSURLSessionDataTask</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这两个方法需要设置代理来接收数据</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request;</span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTaskWithURL:(<span class=\"built_in\">NSURL</span> *)url;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这两个方法在completionHandler来接收数据</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSData</span> * _Nullable data, <span class=\"built_in\">NSURLResponse</span> * _Nullable response, <span class=\"built_in\">NSError</span> * _Nullable error))completionHandler;</span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTaskWithURL:(<span class=\"built_in\">NSURL</span> *)url completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSData</span> * _Nullable data, <span class=\"built_in\">NSURLResponse</span> * _Nullable response, <span class=\"built_in\">NSError</span> * _Nullable error))completionHandler;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&quot;ViewController.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> () &lt;<span class=\"title\">NSURLSessionDelegate</span>,<span class=\"title\">NSURLSessionTaskDelegate</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"comment\">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> sendRequest];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)sendRequest&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建请求</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *url = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@&quot;http://httpbin.org/get&quot;</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableURLRequest</span> *request = [<span class=\"built_in\">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class=\"line\">    <span class=\"comment\">//设置request的缓存策略（决定该request是否要从缓存中获取）</span></span><br><span class=\"line\">    request.cachePolicy = <span class=\"built_in\">NSURLRequestReturnCacheDataElseLoad</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建配置（决定要不要将数据和响应缓存在磁盘）</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">    <span class=\"comment\">//configuration.requestCachePolicy = NSURLRequestReturnCacheDataElseLoad;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建会话</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSession</span> *session = [<span class=\"built_in\">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class=\"keyword\">self</span> delegateQueue:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"comment\">//生成任务</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request];</span><br><span class=\"line\">    <span class=\"comment\">//创建的task是停止状态，需要我们去启动</span></span><br><span class=\"line\">    [task resume];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//1.接收到服务器响应的时候调用</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session dataTask:(<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTask</span><br><span class=\"line\">didReceiveResponse:(<span class=\"built_in\">NSURLResponse</span> *)response</span><br><span class=\"line\"> completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSURLSessionResponseDisposition</span> disposition))completionHandler&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;接收响应&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//必须告诉系统是否接收服务器返回的数据</span></span><br><span class=\"line\">    <span class=\"comment\">//默认是completionHandler(NSURLSessionResponseAllow)</span></span><br><span class=\"line\">    <span class=\"comment\">//可以再这边通过响应的statusCode来判断否接收服务器返回的数据</span></span><br><span class=\"line\">    completionHandler(<span class=\"built_in\">NSURLSessionResponseAllow</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//2.接受到服务器返回数据的时候调用,可能被调用多次</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session dataTask:(<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class=\"built_in\">NSData</span> *)data&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;接收到数据&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//一般在这边进行数据的拼接，在方法3才将完整数据回调</span></span><br><span class=\"line\"><span class=\"comment\">//    NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil];</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//3.请求完成或者是失败的时候调用</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session task:(<span class=\"built_in\">NSURLSessionTask</span> *)task</span><br><span class=\"line\">didCompleteWithError:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSError</span> *)error&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;请求完成或者是失败&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//在这边进行完整数据的解析，回调</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//4.将要缓存响应的时候调用（必须是默认会话模式，GET请求才可以）</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session dataTask:(<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTask</span><br><span class=\"line\"> willCacheResponse:(<span class=\"built_in\">NSCachedURLResponse</span> *)proposedResponse</span><br><span class=\"line\"> completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSCachedURLResponse</span> * _Nullable cachedResponse))completionHandler&#123;</span><br><span class=\"line\">    <span class=\"comment\">//可以在这边更改是否缓存，默认的话是completionHandler(proposedResponse)</span></span><br><span class=\"line\">    <span class=\"comment\">//不想缓存的话可以设置completionHandler(nil)</span></span><br><span class=\"line\">    completionHandler(proposedResponse);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURL</span> *url = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@&quot;http://www.connect.com/login&quot;</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSMutableURLRequest</span> *request = [<span class=\"built_in\">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class=\"line\">request.HTTPMethod = <span class=\"string\">@&quot;POST&quot;</span>;</span><br><span class=\"line\">request.HTTPBody = [<span class=\"string\">@&quot;username=Tom&amp;pwd=123&quot;</span> dataUsingEncoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用全局的会话</span></span><br><span class=\"line\"><span class=\"built_in\">NSURLSession</span> *session = [<span class=\"built_in\">NSURLSession</span> sharedSession];</span><br><span class=\"line\"><span class=\"comment\">// 通过request初始化task</span></span><br><span class=\"line\"><span class=\"built_in\">NSURLSessionTask</span> *task = [session dataTaskWithRequest:request</span><br><span class=\"line\">                                   completionHandler:^(<span class=\"built_in\">NSData</span> *data, <span class=\"built_in\">NSURLResponse</span> *response, <span class=\"built_in\">NSError</span> *error) &#123; </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@&quot;</span>, [<span class=\"built_in\">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:<span class=\"literal\">nil</span>]);</span><br><span class=\"line\"> &#125;];</span><br><span class=\"line\"><span class=\"comment\">//创建的task是停止状态，需要我们去启动</span></span><br><span class=\"line\">[task resume];</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"NSURLSessionUploadTask\"><a href=\"#NSURLSessionUploadTask\" class=\"headerlink\" title=\"NSURLSessionUploadTask\"></a>NSURLSessionUploadTask</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/=========代理方式===========/</span><br><span class=\"line\"><span class=\"comment\">//通过文件url来上传</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request fromFile:(<span class=\"built_in\">NSURL</span> *)fileURL;  </span><br><span class=\"line\"><span class=\"comment\">//通过文件data来上传</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request fromData:(<span class=\"built_in\">NSData</span> *)bodyData;  </span><br><span class=\"line\"><span class=\"comment\">//通过文件流来上传</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionUploadTask</span> *)uploadTaskWithStreamedRequest:(<span class=\"built_in\">NSURLRequest</span> *)request;</span><br><span class=\"line\"></span><br><span class=\"line\">/=========Block方式===========/</span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request fromFile:(<span class=\"built_in\">NSURL</span> *)fileURL completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSData</span> *data, <span class=\"built_in\">NSURLResponse</span> *response, <span class=\"built_in\">NSError</span> *error))completionHandler;  </span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request fromData:(<span class=\"built_in\">NSData</span> *)bodyData completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSData</span> *data, <span class=\"built_in\">NSURLResponse</span> *response, <span class=\"built_in\">NSError</span> *error))completionHandler;</span><br></pre></td></tr></table></figure>\n\n<p>这三种上传方式分别针对什么应用场景呢？</p>\n<ul>\n<li>NSData：如果对象已经在内存里</li>\n<li>File：如果对象在磁盘上，这样做有助于降低内存使用</li>\n<li>Stream：通过流对象，你可以不用一次性将所有的流数据加载到内存中<br>不过使用Stream一定要实现URLSession:task:needNewBodyStream:，因为Session没办法在重新尝试发送Stream的时候找到数据源。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//上传图片</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)uploadRequest&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建请求</span></span><br><span class=\"line\">    <span class=\"built_in\">NSMutableURLRequest</span> * request = [<span class=\"built_in\">NSMutableURLRequest</span> requestWithURL:[<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@&quot;http://www.freeimagehosting.net/upload.php&quot;</span>]];</span><br><span class=\"line\">    <span class=\"comment\">//如果是上传文字就是@&quot;application/json&quot;</span></span><br><span class=\"line\">    [request addValue:<span class=\"string\">@&quot;image/jpeg&quot;</span> forHTTPHeaderField:<span class=\"string\">@&quot;Content-Type&quot;</span>];</span><br><span class=\"line\">    [request addValue:<span class=\"string\">@&quot;text/html&quot;</span> forHTTPHeaderField:<span class=\"string\">@&quot;Accept&quot;</span>];</span><br><span class=\"line\">    [request setHTTPMethod:<span class=\"string\">@&quot;POST&quot;</span>];</span><br><span class=\"line\">    [request setCachePolicy:<span class=\"built_in\">NSURLRequestReloadIgnoringCacheData</span>];</span><br><span class=\"line\">    [request setTimeoutInterval:<span class=\"number\">20</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSData</span> * imagedata = <span class=\"built_in\">UIImageJPEGRepresentation</span>([<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@&quot;person&quot;</span>],<span class=\"number\">1.0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建配置（决定要不要将数据和响应缓存在磁盘）</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">    <span class=\"comment\">//创建会话</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSession</span> *session = [<span class=\"built_in\">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class=\"keyword\">self</span> delegateQueue:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionUploadTask</span> * uploadtask = [session uploadTaskWithRequest:request fromData:imagedata completionHandler:^(<span class=\"built_in\">NSData</span> *data, <span class=\"built_in\">NSURLResponse</span> *response, <span class=\"built_in\">NSError</span> *error) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//发送完成的回调</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    [uploadtask resume];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//发送数据过程中会执行(执行多次)</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session task:(<span class=\"built_in\">NSURLSessionTask</span> *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;发送数据中&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//在这边监听发送的进度</span></span><br><span class=\"line\">    <span class=\"comment\">//progress = totalBytesSent/(float)totalBytesExpectedToSend</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"NSURLSessionDownloadTask\"><a href=\"#NSURLSessionDownloadTask\" class=\"headerlink\" title=\"NSURLSessionDownloadTask\"></a>NSURLSessionDownloadTask</h4><ul>\n<li>下载文件可以实现断点下载</li>\n<li>内部已经完成了边接收数据边写入沙盒的操作（直接下载到磁盘）</li>\n<li>支持BackgroundSession（后台下载）</li>\n</ul>\n<p>使用NSURLSessionDownloadTask 下载文件的过程与前面差不多，需要注意的是文件下载文件之后会自动保存到一个临时目录(temp)，需要开发人员自己将此文件重新放到其他指定的目录中。 或者直接在内存里面显示, 默认异步的.NSURLSession 自动不会出现内存暴涨情况</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/=========代理方式===========/</span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request;  </span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDownloadTask</span> *)downloadTaskWithURL:(<span class=\"built_in\">NSURL</span> *)url;  </span><br><span class=\"line\"><span class=\"comment\">//通过之前已经下载的数据来创建下载任务</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDownloadTask</span> *)downloadTaskWithResumeData:(<span class=\"built_in\">NSData</span> *)resumeData;  </span><br><span class=\"line\"></span><br><span class=\"line\">/=========Block方式===========/</span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSURL</span> *location, <span class=\"built_in\">NSURLResponse</span> *response, <span class=\"built_in\">NSError</span> *error))completionHandler;  </span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDownloadTask</span> *)downloadTaskWithURL:(<span class=\"built_in\">NSURL</span> *)url completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSURL</span> *location, <span class=\"built_in\">NSURLResponse</span> *response, <span class=\"built_in\">NSError</span> *error))completionHandler;  </span><br><span class=\"line\">- (<span class=\"built_in\">NSURLSessionDownloadTask</span> *)downloadTaskWithResumeData:(<span class=\"built_in\">NSData</span> *)resumeData completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSURL</span> *location, <span class=\"built_in\">NSURLResponse</span> *response, <span class=\"built_in\">NSError</span> *error))completionHandler;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)downloadRequest&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建请求</span></span><br><span class=\"line\">    <span class=\"built_in\">NSMutableURLRequest</span> * request = [<span class=\"built_in\">NSMutableURLRequest</span> requestWithURL:[<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@&quot;http://httpbin.org/image/jpeg&quot;</span>]];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建配置（决定要不要将数据和响应缓存在磁盘）</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">    <span class=\"comment\">//创建会话</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSession</span> *session = [<span class=\"built_in\">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class=\"keyword\">self</span> delegateQueue:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionDownloadTask</span> * downloadtask = [session downloadTaskWithRequest:request];</span><br><span class=\"line\">    [downloadtask resume];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1. downloadTask下载过程中会执行</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session downloadTask:(<span class=\"built_in\">NSURLSessionDownloadTask</span> *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;下载中...&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;写入数据大小%lld，总写入数据大小%lld，总期望数据大小%lld&quot;</span>,bytesWritten,totalBytesWritten,totalBytesExpectedToWrite);</span><br><span class=\"line\">    <span class=\"comment\">//监听下载的进度</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//2.downloadTask下载完成的时候会执行</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session downloadTask:(<span class=\"built_in\">NSURLSessionDownloadTask</span> *)downloadTask didFinishDownloadingToURL:(<span class=\"built_in\">NSURL</span> *)location&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;下载完成&quot;</span>);</span><br><span class=\"line\">       <span class=\"comment\">//该方法内部已经完成了边接收数据边写沙盒的操作，解决了内存飙升的问题</span></span><br><span class=\"line\">    <span class=\"comment\">//对数据进行使用，或者保存（默认存储到临时文件夹 tmp 中，需要剪切文件到 cache）</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//保存</span></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *filePath = [[<span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSCachesDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>) lastObject] stringByAppendingPathComponent:downloadTask.response.suggestedFilename];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSFileManager</span> defaultManager] moveItemAtURL:location toURL:[<span class=\"built_in\">NSURL</span> fileURLWithPath:filePath] error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//使用</span></span><br><span class=\"line\">    <span class=\"built_in\">NSData</span> * data = [<span class=\"built_in\">NSData</span> dataWithContentsOfURL:location.filePathURL];</span><br><span class=\"line\">    <span class=\"built_in\">UIImage</span> * image = [<span class=\"built_in\">UIImage</span> imageWithData:data];</span><br><span class=\"line\">    <span class=\"built_in\">UIImageWriteToSavedPhotosAlbum</span>(image, <span class=\"literal\">nil</span>,<span class=\"literal\">nil</span>,<span class=\"literal\">nil</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//3.请求完成或者是失败的时候调用(Session层次的Task完成的事件)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session task:(<span class=\"built_in\">NSURLSessionTask</span> *)task</span><br><span class=\"line\">didCompleteWithError:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSError</span> *)error&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;请求完成或者是失败&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>断点续传:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用这种方式取消下载可以得到将来用来恢复的数据,保存起来</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.task cancelByProducingResumeData:^(<span class=\"built_in\">NSData</span> *resumeData) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.resumeData = resumeData;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 由于下载失败导致的下载中断会进入此协议方法,也可以得到用来恢复的数据</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session task:(<span class=\"built_in\">NSURLSessionTask</span> *)task didCompleteWithError:(<span class=\"built_in\">NSError</span> *)error</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 保存恢复数据</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.resumeData = error.userInfo[<span class=\"built_in\">NSURLSessionDownloadTaskResumeData</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 恢复下载时接过保存的恢复数据</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.task = [<span class=\"keyword\">self</span>.session downloadTaskWithResumeData:<span class=\"keyword\">self</span>.resumeData];</span><br><span class=\"line\"><span class=\"comment\">// 启动任务</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.task resume];</span><br></pre></td></tr></table></figure>\n\n<p>后台下载</p>\n<p>使用后台会话进行下程序退出到后台也能正常下载完成,但是程序在后台UI无法更新,不能获取进度;这时,我们需要通过应用程序代理进行UI更新,原理如图:</p>\n<p><img src=\"/images/img1.png\"></p>\n<p>当NSURLSession在后台开启几个任务之后,如果其中有任务完成,系统就会会调用此APP的代理方法:<code>- (void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifiercompletionHandler:(void (^)(void))completionHandler</code>里进行完成的操作. 通常我们会保持此对象,直到最后一个任务完成;<br>此时会重新通过会话标识(config中设置的)找到对应会话并调用NSURLSession的<code>-(void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession * )session</code>代理方法例进行UI的更新.并调用completionHandler通知系统已经完成所有操作。具体如下:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">void</span>)application:(<span class=\"built_in\">UIApplication</span> *)application handleEventsForBackgroundURLSession:(<span class=\"built_in\">NSString</span> *)identifier completionHandler:(<span class=\"keyword\">void</span> (^)())completionHandler&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//backgroundSessionCompletionHandler是自定义的一个属性</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.backgroundSessionCompletionHandler=completionHandler;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)URLSessionDidFinishEventsForBackgroundURLSession:(<span class=\"built_in\">NSURLSession</span> *)session&#123;</span><br><span class=\"line\">    AppDelegate *appDelegate = (AppDelegate *)[[<span class=\"built_in\">UIApplication</span> sharedApplication] delegate];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Other Operation....</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (appDelegate.backgroundSessionCompletionHandler) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">void</span> (^completionHandler)() = appDelegate.backgroundSessionCompletionHandler;     </span><br><span class=\"line\">        appDelegate.backgroundSessionCompletionHandler = <span class=\"literal\">nil</span>;        </span><br><span class=\"line\">        completionHandler();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用GCD进行一次发起多个请求，全部完成后进行统一处理</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let group : dispatch_group_t = dispatch_group_create()</span><br><span class=\"line\">let queue : <span class=\"built_in\">dispatch_queue_t</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">dispatch_group_async(group, queue) &#123; </span><br><span class=\"line\">  dispatch_group_enter(group)</span><br><span class=\"line\">  <span class=\"comment\">//发起第一个请求</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_group_async(group, queue) &#123;</span><br><span class=\"line\">  dispatch_group_enter(group)</span><br><span class=\"line\">  <span class=\"comment\">//发起第二个请求</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_group_notify(group, queue) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//全部完成后，进行统一处理</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//每个请求完成时，调用dispatch_group_leave(group)</span></span><br></pre></td></tr></table></figure>\n\n<p>参考:</br><br><a href=\"https://www.jianshu.com/p/a8fc22afb739\">https://www.jianshu.com/p/a8fc22afb739</a><br><a href=\"http://blog.csdn.net/csdnhaoren13/article/details/50809506\">http://blog.csdn.net/csdnhaoren13/article/details/50809506</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}